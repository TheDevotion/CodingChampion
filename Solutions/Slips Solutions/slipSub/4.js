export const DataStructure = {
  subject: 'Data Structure',
  slips: [
    {
      slipId: 1,
      questions: [
        {
          questionId: 1,
          text: `Write a menu driven program using ‘C’ for Binary Search Tree.<br> The menu includes:<br> - Create a Binary Search Tree<br> - Insert element in a Binary Search Tree<br> - Display`,
          marks: 20,
          sol: `#include <stdio.h>\n#include <stdlib.h> // For malloc and exit\n#include <conio.h>  // For clrscr and getche\n\n// Structure for a tree node\nstruct NODE\n{\n     struct NODE *lchild; // Left child\n     int data;            // Node data\n     struct NODE *rchild; // Right child\n};\n\ntypedef struct NODE node; // Node alias\n\n// Create a new node\nnode *getnode()\n{\n     node *temp;\n     temp = (node *)malloc(sizeof(node)); // Allocate memory\n     if (temp == NULL)\n     {\n          printf(\"Memory allocation failed\\n\");\n          exit(1); // Exit if memory allocation fails\n     }\n     printf(\"\\nEnter the data: \");\n     scanf(\"%d\", &temp->data); // Input data\n     temp->lchild = NULL;      // Initialize left child\n     temp->rchild = NULL;      // Initialize right child\n     return temp;\n}\n\n// Create a BST\nnode *create()\n{\n     int ch;\n     node *root = NULL, *temp, *ptr;\n\n     do\n     {\n          temp = getnode(); // Create a new node\n          if (root == NULL)\n          {\n               root = temp; // Set as root if tree is empty\n          }\n          else\n          {\n               ptr = root;\n               while (ptr != NULL)\n               {\n                    if (temp->data < ptr->data)\n                    {\n                         if (ptr->lchild == NULL)\n                         {\n                              ptr->lchild = temp; // Insert as left child\n                              break;\n                         }\n                         else\n                         {\n                              ptr = ptr->lchild; // Move to left child\n                         }\n                    }\n                    else\n                    {\n                         if (ptr->rchild == NULL)\n                         {\n                              ptr->rchild = temp; // Insert as right child\n                              break;\n                         }\n                         else\n                         {\n                              ptr = ptr->rchild; // Move to right child\n                         }\n                    }\n               }\n          }\n          printf(\"\\nDo you want to add more nodes (Y/N): \");\n          ch = getche(); // Get user choice\n     } while (ch == 'Y' || ch == 'y');\n\n     return root; // Return the root\n}\n\n// Insert a node into a BST\nnode *insert(node *root, node *temp)\n{\n     node *ptr;\n\n     if (root == NULL)\n     {\n          root = temp; // Set as root if tree is empty\n     }\n     else\n     {\n          ptr = root;\n          while (ptr != NULL)\n          {\n               if (temp->data < ptr->data)\n               {\n                    if (ptr->lchild == NULL)\n                    {\n                         ptr->lchild = temp; // Insert as left child\n                         break;\n                    }\n                    else\n                    {\n                         ptr = ptr->lchild; // Move to left child\n                    }\n               }\n               else\n               {\n                    if (ptr->rchild == NULL)\n                    {\n                         ptr->rchild = temp; // Insert as right child\n                         break;\n                    }\n                    else\n                    {\n                         ptr = ptr->rchild; // Move to right child\n                    }\n               }\n          }\n     }\n\n     return root; // Return the root\n}\n\n// Display the BST\nvoid display(node *ptr)\n{\n     if (ptr != NULL)\n     {\n          display(ptr->lchild);     // Display left subtree\n          printf(\" %d\", ptr->data); // Display node data\n          display(ptr->rchild);     // Display right subtree\n     }\n}\n\n// Main function\nvoid main()\n{\n     int ch;\n     node *root = NULL, *temp;\n\n     clrscr(); // Clear the screen\n     while (1)\n     {\n          printf(\"\\n1: Create a BST.\");\n          printf(\"\\n2: Insert element into a BST.\");\n          printf(\"\\n3: Display\");\n          printf(\"\\n4: Exit\");\n          printf(\"\\nEnter the Choice: \");\n          scanf(\"%d\", &ch); // Get user choice\n          switch (ch)\n          {\n          case 1:\n               root = create(); // Create a new BST\n               break;\n          case 2:\n               temp = getnode();          // Create a new node\n               root = insert(root, temp); // Insert the node\n               break;\n          case 3:\n               display(root); // Display the BST\n               break;\n          case 4:\n               exit(0); // Exit the program\n          }\n     }\n}`,
        },
        {
          questionId: 2,
          text: `Write a ‘C’ program to evaluate a given polynomial using function. (Use array).`,
          marks: 10,
          sol: `#include <stdio.h>\n#include <conio.h>\n#include <math.h>\n\n#define MAX 10 // Maximum number of coefficients\n\n// Function to evaluate the polynomial\nfloat evaluatePolynomial(int coeffs[], int degree, float x)\n{\n     float result = 0;\n     int i;\n     for (i = 0; i <= degree; i++)\n     {\n          result += coeffs[i] * pow(x, i);\n     }\n     return result;\n}\n\nvoid main()\n{\n     int coeffs[MAX]; // Array to store coefficients\n     int degree, i;\n     float x, result;\n\n     clrscr(); // Clear the screen\n\n     // Read the degree of the polynomial\n     printf(\"Enter the degree of the polynomial: \");\n     scanf(\"%d\", &degree);\n\n     // Ensure degree is within bounds\n     if (degree >= MAX)\n     {\n          printf(\"Degree exceeds the maximum allowed (%d).\\n\", MAX - 1);\n          getch(); // Wait for a key press\n          return;\n     }\n\n     // Read the coefficients of the polynomial\n     printf(\"Enter the coefficients (from lowest degree to highest degree):\\n\");\n     for (i = 0; i <= degree; i++)\n     {\n          printf(\"Coefficient of x^%d: \", i);\n          scanf(\"%d\", &coeffs[i]);\n     }\n\n     // Read the value of x\n     printf(\"Enter the value of x: \");\n     scanf(\"%f\", &x);\n\n     // Evaluate the polynomial\n     result = evaluatePolynomial(coeffs, degree, x);\n\n     // Display the result\n     printf(\"The value of the polynomial at x = %.2f is: %.2f\\n\", x, result);\n\n     getch(); // Wait for a key press\n}
`,
        },
      ],
    },
    {
      slipId: 2,
      questions: [
        {
          questionId: 1,
          text: `Write a ‘C’ program to accept a string from a user and reverse it using Static implementation of Stack.`,
          marks: 20,
          sol: `#include <stdio.h>\n#include <conio.h>\n#define MAX 50\n\nstruct STACK\n{\n     char stk[MAX];\n     int top;\n};\ntypedef struct STACK stack;\n\nvoid initstack(stack *s)\n{\n     s->top = -1; // Initialize top to -1 (stack is empty)\n}\n\nint isempty(stack *s)\n{\n     return s->top == -1; // Return 1 if empty, else 0\n}\n\nint isfull(stack *s)\n{\n     return s->top == MAX - 1; // Return 1 if full, else 0\n}\n\nvoid push(stack *s, char data)\n{\n     s->stk[++s->top] = data; // Push data onto stack\n}\n\nchar pop(stack *s)\n{\n     return s->stk[s->top--]; // Pop data from stack\n}\n\nvoid main()\n{\n     stack s;\n     char string[MAX];\n     int i;\n     clrscr();\n\n     initstack(&s); // Initialize the stack\n\n     printf(\"\\nEnter the String: \");\n     gets(string); // Input string\n\n     for (i = 0; string[i] != '\\0'; i++)\n     {\n          if (isfull(&s))\n               printf(\"\\nStack is FULL.\");\n          else\n               push(&s, string[i]); // Push each char to stack\n     }\n\n     printf(\"\\nReverse String: \");\n     while (!isempty(&s))\n          printf(\"%c\", pop(&s)); // Pop to reverse the string\n\n     getch(); // Wait for key press\n}
`,
        },
        {
          questionId: 2,
          text: `Write a ‘C’ program to create a Circularly Doubly Linked list and display it.`,
          marks: 10,
          sol: `#include <stdio.h>\n#include <conio.h>\n#include <malloc.h> // For malloc function\n\n// Define a node in the circular doubly linked list\nstruct NODE\n{\n     int data;\n     struct NODE *next;\n     struct NODE *prev;\n};\ntypedef struct NODE node;\nnode *head = NULL; // Head of the list\n\n// Function to create a new node\nnode *getnode()\n{\n     node *temp;\n     temp = (node *)malloc(sizeof(node));\n     printf(\"\\nEnter the data: \");\n     scanf(\"%d\", &temp->data);\n     temp->next = NULL;\n     temp->prev = NULL;\n     return temp;\n}\n\n// Function to create a Circular Doubly Linked List\nvoid create()\n{\n     int n, i;\n     node *temp, *last;\n\n     printf(\"\\nEnter the number of nodes: \");\n     scanf(\"%d\", &n);\n\n     if (n <= 0)\n     {\n          printf(\"\\nInvalid number of nodes.\");\n          return;\n     }\n\n     // Create the first node\n     head = getnode();\n     last = head;\n\n     // Create the remaining nodes\n     for (i = 1; i < n; i++)\n     {\n          temp = getnode();\n          last->next = temp;\n          temp->prev = last;\n          last = temp;\n     }\n\n     // Link the last node to the head to make it circular\n     last->next = head;\n     head->prev = last;\n}\n\n// Function to display the Circular Doubly Linked List\nvoid display()\n{\n     node *ptr;\n\n     if (head == NULL)\n     {\n          printf(\"\\nThe list is empty.\");\n          return;\n     }\n\n     printf(\"\\nThe Circular Doubly Linked List is:\\n\");\n     ptr = head;\n\n     // Traverse the list and print data\n     do\n     {\n          printf(\"%d <-> \", ptr->data);\n          ptr = ptr->next;\n     } while (ptr != head);\n\n     printf(\"(head)\\n\"); // Indicate that we have come back to the head\n}\n\nvoid main()\n{\n     clrscr(); // Clear the screen\n\n     create();  // Create the Circular Doubly Linked List\n     display(); // Display the Circular Doubly Linked List\n\n     getch(); // Wait for a key press\n}

`,
        },
      ],
    },
    {
      slipId: 3,
      questions: [
        {
          questionId: 1,
          text: `Write a program to create two singly linked lists of elements of type integer and find the union of the linked lists. (Accept elements in the sorted order)`,
          marks: 20,
          sol: `#include<stdio.h>\n#include<conio.h>\n#include<stdlib.h> // Include for malloc\n\nstruct NODE\n{\n     int data;\n     struct NODE *next;\n};\ntypedef struct NODE node;\n\n// Function to create a new node and input data\nnode *getnode()\n{\n     node *temp;\n     temp = (node *)malloc(sizeof(node)); // Allocate memory for the new node\n     printf(\"\\nEnter the data: \");\n     scanf(\"%d\", &temp->data);\n     temp->next = NULL; // Initialize next pointer to NULL\n     return temp;\n}\n\n// Function to create a linked list by appending nodes\nnode *create(node *list)\n{\n     node *temp, *last;\n     int n, i;\n     printf(\"\\nEnter total nodes: \");\n     scanf(\"%d\", &n);\n     for (i = 0; i < n; i++)\n     {\n          temp = getnode();\n          if (list == NULL)\n          {\n               list = temp; // First node becomes the list head\n          }\n          else\n          {\n               // Traverse to the end and append the new node\n               for (last = list; last->next != NULL; last = last->next)\n                    ;\n               last->next = temp;\n          }\n     }\n     return list;\n}\n\n// Function to display the linked list\nvoid display(node *list)\n{\n     node *ptr;\n     for (ptr = list; ptr != NULL; ptr = ptr->next)\n     {\n          printf(\"%d->\", ptr->data);\n     }\n     printf(\"NULL\");\n}\n\n// Function to create a new node with given data\nnode *getnodenum(int digit)\n{\n     node *temp;\n     temp = (node *)malloc(sizeof(node));\n     temp->data = digit;\n     temp->next = NULL; // Initialize next pointer to NULL\n     return temp;\n}\n\n// Function to search for a node with a specific value\nnode *search(int val, node *list1)\n{\n     node *ptr;\n     for (ptr = list1; ptr != NULL && ptr->data != val; ptr = ptr->next)\n          ;\n     return ptr; // Returns NULL if not found\n}\n\n// Function to create the union of two linked lists\nnode *unionlist(node *list1, node *list2)\n{\n     node *lunion = NULL, *ptr1, *last, *temp, *ptr2, *ptr;\n\n     // Add all nodes from list1 to lunion\n     for (ptr1 = list1; ptr1 != NULL; ptr1 = ptr1->next)\n     {\n          temp = getnodenum(ptr1->data);\n          if (lunion == NULL)\n          {\n               lunion = temp; // First node in union list\n          }\n          else\n          {\n               for (last = lunion; last->next != NULL; last = last->next)\n                    ;\n               last->next = temp; // Append node to the end of lunion\n          }\n     }\n\n     // Add nodes from list2 only if they aren't in list1\n     for (ptr2 = list2; ptr2 != NULL; ptr2 = ptr2->next)\n     {\n          ptr = search(ptr2->data, list1);\n          if (ptr == NULL)\n          { // If not found in list1\n               temp = getnodenum(ptr2->data);\n               for (last = lunion; last->next != NULL; last = last->next)\n                    ;\n               last->next = temp; // Append node to the end of lunion\n          }\n     }\n\n     return (lunion); // Return the union of list1 and list2\n}\n\nvoid main()\n{\n     node *list1 = NULL, *list2 = NULL, *lunion;\n\n     clrscr();\n\n     printf(\"\\nCreate list1: \");\n     list1 = create(list1);\n\n     printf(\"\\nCreate List2: \");\n     list2 = create(list2);\n\n     printf(\"\\nList1 is: \");\n     display(list1);\n\n     printf(\"\\nList2 is : \");\n     display(list2);\n\n     lunion = unionlist(list1, list2); // Create union of list1 and list2\n\n     printf(\"\\nList after Union: \");\n     display(lunion);\n\n     getch();\n}
`,
        },
        {
          questionId: 2,
          text: `Write a ‘C’ program to read the adjacency matrix of a directed graph and convert it into an adjacency list.`,
          marks: 10,
          sol: `#include<stdio.h>\n#include<conio.h>\n#include<malloc.h> // For malloc function\n\n#define MAX_VERTICES 20 // Maximum number of vertices\n\n// Define the structure for an adjacency list node\nstruct AdjListNode\n{\n     int dest;\n     struct AdjListNode *next;\n};\ntypedef struct AdjListNode AdjListNode;\n\n// Define the structure for an adjacency list\nstruct AdjList\n{\n     AdjListNode *head;\n};\ntypedef struct AdjList AdjList;\n\n// Define the graph structure\nstruct Graph\n{\n     int numVertices;\n     AdjList *array;\n};\ntypedef struct Graph Graph;\n\n// Function to create a new adjacency list node\nAdjListNode *createNode(int dest)\n{\n     AdjListNode *newNode = (AdjListNode *)malloc(sizeof(AdjListNode));\n     newNode->dest = dest;\n     newNode->next = NULL;\n     return newNode;\n}\n\n// Function to create a graph with a given number of vertices\nGraph *createGraph(int vertices)\n{\n     Graph *graph = (Graph *)malloc(sizeof(Graph));\n     graph->numVertices = vertices;\n\n     // Create an array of adjacency lists\n     graph->array = (AdjList *)malloc(vertices * sizeof(AdjList));\n\n     // Initialize each adjacency list as empty\n     int i;\n     for (i = 0; i < vertices; ++i)\n          graph->array[i].head = NULL;\n\n     return graph;\n}\n\n// Function to add an edge to the graph\nvoid addEdge(Graph *graph, int src, int dest)\n{\n     // Add an edge from src to dest\n     AdjListNode *newNode = createNode(dest);\n     newNode->next = graph->array[src].head;\n     graph->array[src].head = newNode;\n}\n\n// Function to print the adjacency list representation of the graph\nvoid printGraph(Graph *graph)\n{\n     int v;\n     for (v = 0; v < graph->numVertices; ++v)\n     {\n          AdjListNode *pCrawl = graph->array[v].head;\n          printf(\"\\nAdjacency list of vertex %d\\n head\", v);\n          while (pCrawl)\n          {\n               printf(\" -> %d\", pCrawl->dest);\n               pCrawl = pCrawl->next;\n          }\n          printf(\"\\n\");\n     }\n}\n\nvoid main()\n{\n     int i, j, numVertices;\n     int adjMatrix[MAX_VERTICES][MAX_VERTICES];\n     Graph *graph;\n\n     clrscr(); // Clear the screen\n\n     printf(\"Enter the number of vertices in the graph: \");\n     scanf(\"%d\", &numVertices);\n\n     printf(\"Enter the adjacency matrix:\\n\");\n     for (i = 0; i < numVertices; i++)\n     {\n          for (j = 0; j < numVertices; j++)\n          {\n               scanf(\"%d\", &adjMatrix[i][j]);\n          }\n     }\n\n     // Create a graph\n     graph = createGraph(numVertices);\n\n     // Convert adjacency matrix to adjacency list\n     for (i = 0; i < numVertices; i++)\n     {\n          for (j = 0; j < numVertices; j++)\n          {\n               if (adjMatrix[i][j] == 1)\n               {\n                    addEdge(graph, i, j);\n               }\n          }\n     }\n\n     // Print the adjacency list\n     printGraph(graph);\n\n     getch(); // Wait for a key press\n}
`,
        },
      ],
    },
    {
      slipId: 4,
      questions: [
        {
          questionId: 1,
          text: `Write a menu driven program using ‘C’ for Binary Search Tree.<br> The menu includes:<br> - Create a Binary Search Tree<br> - Traverse it by using Inorder and Postorder traversing technique`,
          marks: 20,
          sol: `#include<stdio.h>\n#include<conio.h>\n#include<stdlib.h> // For malloc function\n\nstruct NODE\n{\n     struct NODE *lchild;\n     int data;\n     struct NODE *rchild;\n};\ntypedef struct NODE node;\n\n// Create and initialize a new node\nnode *getnode()\n{\n     node *temp;\n     temp = (node *)malloc(sizeof(node)); // Allocate node memory\n     printf(\"\\nEnter the data: \");\n     scanf(\"%d\", &temp->data);\n     temp->lchild = NULL; // Set left child to NULL\n     temp->rchild = NULL; // Set right child to NULL\n     return temp;\n}\n\n// Create a Binary Search Tree (BST)\nnode *create()\n{\n     int ch;\n     node *root = NULL, *temp, *ptr;\n\n     do\n     {\n          temp = getnode(); // Create new node\n          if (root == NULL)\n               root = temp; // Set root if tree is empty\n          else\n          {\n               ptr = root;\n               while (ptr != NULL)\n               {\n                    if (temp->data < ptr->data)\n                    {\n                         if (ptr->lchild == NULL)\n                         {\n                              ptr->lchild = temp; // Add to left if available\n                              break;\n                         }\n                         else\n                              ptr = ptr->lchild;\n                    }\n                    else\n                    {\n                         if (ptr->rchild == NULL)\n                         {\n                              ptr->rchild = temp; // Add to right if available\n                              break;\n                         }\n                         else\n                              ptr = ptr->rchild;\n                    }\n               }\n          }\n          printf(\"\\nDo you want to add more node(Y/N): \");\n          ch = getche(); // Read user choice\n     } while (ch == 'Y' || ch == 'y'); // Continue adding nodes\n\n     return root;\n}\n\n// Inorder traversal of the BST\nvoid inorder(node *ptr)\n{\n     if (ptr != NULL)\n     {\n          inorder(ptr->lchild);     // Visit left subtree\n          printf(\" %d\", ptr->data); // Print node data\n          inorder(ptr->rchild);     // Visit right subtree\n     }\n}\n\n// Postorder traversal of the BST\nvoid postorder(node *ptr)\n{\n     if (ptr != NULL)\n     {\n          postorder(ptr->lchild);   // Visit left subtree\n          postorder(ptr->rchild);   // Visit right subtree\n          printf(\" %d\", ptr->data); // Print node data\n     }\n}\n\nvoid main()\n{\n     int ch;\n     node *root = NULL; // Initialize root\n\n     clrscr(); // Clear screen\n\n     while (1)\n     {\n          printf(\"\\n1:Create a BST.\");\n          printf(\"\\n2:Inorder of BST.\");\n          printf(\"\\n3:Postorder of BST\");\n          printf(\"\\n4:Exit\");\n          printf(\"\\nEnter the Choice:\");\n          scanf(\"%d\", &ch); // Read user choice\n\n          switch (ch)\n          {\n          case 1:\n               root = create(); // Create BST\n               break;\n          case 2:\n               inorder(root); // Display inorder traversal\n               break;\n          case 3:\n               postorder(root); // Display postorder traversal\n               break;\n          case 4:\n               exit(0); // Exit program\n          }\n     }\n\n     getch(); // Wait for user input\n}
`,
        },
        {
          questionId: 2,
          text: `Write a ‘C’ program to accept two polynomials and find the addition of accepted polynomials. (Use array)`,
          marks: 10,
          sol: `#include<stdio.h>\n#include<conio.h>\n\n#define MAX_TERMS 10 // Define maximum number of terms in a polynomial\n\n// Function to read a polynomial\nvoid readPolynomial(int poly[], int *degree)\n{\n     int i;\n     printf(\"Enter the degree of the polynomial: \");\n     scanf(\"%d\", degree);\n\n     printf(\"Enter the coefficients from highest degree to lowest:\\n\");\n     for (i = *degree; i >= 0; i--)\n     {\n          printf(\"Coefficient of x^%d: \", i);\n          scanf(\"%d\", &poly[i]);\n     }\n}\n\n// Function to print a polynomial\nvoid printPolynomial(int poly[], int degree)\n{\n     int i;\n     printf(\"Polynomial: \");\n     for (i = degree; i >= 0; i--)\n     {\n          if (i != degree && poly[i] >= 0)\n               printf(\" + \");\n          if (i == 0)\n               printf(\"%d\", poly[i]);\n          else\n               printf(\"%dx^%d\", poly[i], i);\n     }\n     printf(\"\\n\");\n}\n\n// Function to add two polynomials\nvoid addPolynomials(int poly1[], int degree1, int poly2[], int degree2, int result[], int *resultDegree)\n{\n     int i, maxDegree;\n\n     // Determine the maximum degree of the result polynomial\n     if (degree1 > degree2)\n          maxDegree = degree1;\n     else\n          maxDegree = degree2;\n\n     // Initialize result polynomial to 0\n     for (i = 0; i <= maxDegree; i++)\n          result[i] = 0;\n\n     // Add coefficients of the first polynomial\n     for (i = 0; i <= degree1; i++)\n          result[i] += poly1[i];\n\n     // Add coefficients of the second polynomial\n     for (i = 0; i <= degree2; i++)\n          result[i] += poly2[i];\n\n     // Set the degree of the result polynomial\n     *resultDegree = maxDegree;\n}\n\nvoid main()\n{\n     int poly1[MAX_TERMS], poly2[MAX_TERMS], result[MAX_TERMS];\n     int degree1, degree2, resultDegree;\n\n     clrscr(); // Clear the screen\n\n     // Read the first polynomial\n     printf(\"Enter the first polynomial:\\n\");\n     readPolynomial(poly1, &degree1);\n\n     // Read the second polynomial\n     printf(\"Enter the second polynomial:\\n\");\n     readPolynomial(poly2, &degree2);\n\n     // Add the two polynomials\n     addPolynomials(poly1, degree1, poly2, degree2, result, &resultDegree);\n\n     // Print the polynomials and the result\n     printf(\"First \");\n     printPolynomial(poly1, degree1);\n\n     printf(\"Second \");\n     printPolynomial(poly2, degree2);\n\n     printf(\"Sum \");\n     printPolynomial(result, resultDegree);\n\n     getch(); // Wait for a key press\n}
`,
        },
      ],
    },
    {
      slipId: 5,
      questions: [
        {
          questionId: 1,
          text: `Write a menu driven program using ‘C’ for Binary Search Tree.<br> The menu includes:<br> - Create a Binary Search Tree<br> - Traverse it by using Inorder and Preorder traversing technique`,
          marks: 20,
          sol: `#include<stdio.h>\n#include<conio.h>\n\nstruct NODE\n{\n     struct NODE *lchild;\n     int data;\n     struct NODE *rchild;\n};\n\ntypedef struct NODE node;\n\n// Create a new node and initialize\nnode *getnode()\n{\n     node *temp;\n     temp = (node *)malloc(sizeof(node)); // Allocate memory\n     printf(\"\\nEnter the data: \");\n     scanf(\"%d\", &temp->data);\n     temp->lchild = NULL; // Set left child to NULL\n     temp->rchild = NULL; // Set right child to NULL\n     return temp;\n}\n\n// Create a Binary Search Tree (BST)\nnode *create()\n{\n     int ch;\n     node *root = NULL, *temp, *ptr;\n\n     do\n     {\n          temp = getnode(); // Create a new node\n          if (root == NULL)\n               root = temp; // Set root if tree is empty\n          else\n          {\n               ptr = root;\n               while (ptr != NULL)\n               {\n                    if (temp->data < ptr->data)\n                    {\n                         if (ptr->lchild == NULL)\n                         {\n                              ptr->lchild = temp; // Add to left if available\n                              break;\n                         }\n                         else\n                              ptr = ptr->lchild;\n                    }\n                    else\n                    {\n                         if (ptr->rchild == NULL)\n                         {\n                              ptr->rchild = temp; // Add to right if available\n                              break;\n                         }\n                         else\n                              ptr = ptr->rchild;\n                    }\n               }\n          }\n          printf(\"\\nDo you want to add more node(Y/N): \");\n          ch = getche(); // Get user choice\n     } while (ch == 'Y' || ch == 'y'); // Repeat if 'Y' or 'y'\n\n     return root;\n}\n\n// Inorder traversal of the BST\nvoid inorder(node *ptr)\n{\n     if (ptr != NULL)\n     {\n          inorder(ptr->lchild);     // Visit left subtree\n          printf(\" %d\", ptr->data); // Print node data\n          inorder(ptr->rchild);     // Visit right subtree\n     }\n}\n\n// Preorder traversal of the BST\nvoid preorder(node *ptr)\n{\n     if (ptr != NULL)\n     {\n          printf(\" %d\", ptr->data); // Print node data\n          preorder(ptr->lchild);    // Visit left subtree\n          preorder(ptr->rchild);    // Visit right subtree\n     }\n}\n\nvoid main()\n{\n     int ch;\n     node *root = NULL; // Initialize root\n     clrscr();          // Clear screen\n\n     while (1)\n     {\n          printf(\"\\n1:Create a BST.\");\n          printf(\"\\n2:Inorder of BST.\");\n          printf(\"\\n3:Preorder of BST\");\n          printf(\"\\n4:Exit\");\n          printf(\"\\nEnter the Choice:\");\n          scanf(\"%d\", &ch); // Read user choice\n\n          switch (ch)\n          {\n          case 1:\n               root = create(); // Create BST\n               break;\n          case 2:\n               inorder(root); // Display inorder traversal\n               break;\n          case 3:\n               preorder(root); // Display preorder traversal\n               break;\n          case 4:\n               exit(0); // Exit program\n          }\n     }\n\n     getch(); // Wait for user input\n}
`,
        },
        {
          questionId: 2,
          text: `Write a ‘C’ program to create a linked list with a given number in which data part of each node contains an individual digit of the number.<br> (Ex. Suppose the number is 368 then the nodes of linked list should contain 3, 6, 8)`,
          marks: 10,
          sol: `#include<stdio.h>\n#include<conio.h>\n\nstruct NODE\n{\n     int data;\n     struct NODE *next;\n};\n\ntypedef struct NODE node;\n\nnode *list = NULL, *last;\n\n// Create a node with given data\nnode *getnodenum(int digit)\n{\n     node *temp;\n     temp = (node *)malloc(sizeof(node)); // Allocate memory\n     temp->data = digit;                  // Set node data\n     temp->next = NULL;                   // Initialize next to NULL\n     return temp;\n}\n\n// Create linked list from digits of the number\nvoid createnumll(int num)\n{\n     int rem;\n     node *temp;\n     while (num > 0)\n     {\n          rem = num % 10;         // Get last digit\n          num = num / 10;         // Remove last digit\n          temp = getnodenum(rem); // Create new node\n          if (list == NULL)\n               list = temp; // Set first node\n          else\n          {\n               temp->next = list; // Insert at beginning\n               list = temp;       // Update head\n          }\n     }\n}\n\n// Display the linked list\nvoid display()\n{\n     node *ptr;\n     for (ptr = list; ptr != NULL; ptr = ptr->next)\n          printf(\"%d->\", ptr->data); // Print node data\n     printf(\"NULL\");                 // End of list\n}\n\nvoid main()\n{\n     int num;\n     clrscr(); // Clear screen\n     printf(\"\\nEnter the No: \");\n     scanf(\"%d\", &num); // Read number\n     createnumll(num);  // Create list from number\n     printf(\"\\nLinked after separating the digits of num: \");\n     display(); // Display linked list\n     getch();   // Wait for user input\n}
`,
        },
      ],
    },
    {
      slipId: 6,
      questions: [
        {
          questionId: 1,
          text: `Write a menu driven program using ‘C’ for Binary Search Tree.<br> The menu includes:<br> - Create a Binary Search Tree<br> - Traverse it by using Preorder and Postorder traversing technique`,
          marks: 20,
          sol: `#include<stdio.h>\n#include<conio.h>\n\nstruct NODE\n{\n     struct NODE *lchild; // Pointer to left child\n     int data;            // Node data\n     struct NODE *rchild; // Pointer to right child\n};\n\ntypedef struct NODE node;\n\n// Create and initialize a new node\nnode *getnode()\n{\n     node *temp;\n     temp = (node *)malloc(sizeof(node)); // Allocate memory\n     printf(\"\\nEnter the data: \");\n     scanf(\"%d\", &temp->data); // Read node data\n     temp->lchild = NULL;      // Initialize left child\n     temp->rchild = NULL;      // Initialize right child\n     return temp;\n}\n\n// Create a Binary Search Tree (BST)\nnode *create()\n{\n     int ch;\n     node *root = NULL, *temp, *ptr;\n\n     do\n     {\n          temp = getnode(); // Create new node\n          if (root == NULL)\n               root = temp; // Set root if tree is empty\n          else\n          {\n               ptr = root;\n               while (ptr != NULL)\n               {\n                    if (temp->data < ptr->data)\n                    {\n                         if (ptr->lchild == NULL)\n                         {\n                              ptr->lchild = temp; // Add to left child\n                              break;\n                         }\n                         else\n                              ptr = ptr->lchild; // Move to left child\n                    }\n                    else\n                    {\n                         if (ptr->rchild == NULL)\n                         {\n                              ptr->rchild = temp; // Add to right child\n                              break;\n                         }\n                         else\n                              ptr = ptr->rchild; // Move to right child\n                    }\n               }\n          }\n          printf(\"\\nDo you want to add more node(Y/N): \");\n          ch = getche(); // Read user choice\n     } while (ch == 'Y' || ch == 'y'); // Continue if 'Y' or 'y'\n\n     return root;\n}\n\n// Postorder traversal of the BST\nvoid postorder(node *ptr)\n{\n     if (ptr != NULL)\n     {\n          postorder(ptr->lchild);   // Visit left subtree\n          postorder(ptr->rchild);   // Visit right subtree\n          printf(\" %d\", ptr->data); // Print node data\n     }\n}\n\n// Preorder traversal of the BST\nvoid preorder(node *ptr)\n{\n     if (ptr != NULL)\n     {\n          printf(\" %d\", ptr->data); // Print node data\n          preorder(ptr->lchild);    // Visit left subtree\n          preorder(ptr->rchild);    // Visit right subtree\n     }\n}\n\nvoid main()\n{\n     int ch;\n     node *root = NULL; // Initialize root\n     clrscr();          // Clear screen\n\n     while (1)\n     {\n          printf(\"\\n1:Create a BST.\");\n          printf(\"\\n2:Preorder of BST.\");\n          printf(\"\\n3:Postorder of BST\");\n          printf(\"\\n4:Exit\");\n          printf(\"\\nEnter the Choice:\");\n          scanf(\"%d\", &ch); // Read user choice\n\n          switch (ch)\n          {\n          case 1:\n               root = create(); // Create BST\n               break;\n          case 2:\n               preorder(root); // Display preorder traversal\n               break;\n          case 3:\n               postorder(root); // Display postorder traversal\n               break;\n          case 4:\n               exit(0); // Exit program\n          }\n     }\n\n     getch(); // Wait for user input\n}
`,
        },
        {
          questionId: 2,
          text: `Write a ‘C’ program to accept and sort n elements in ascending order by using bubble sort.`,
          marks: 10,
          sol: `#include<stdio.h>\n#include<conio.h>\n\n#define MAX 100 // Define maximum number of elements\n\n// Function to perform bubble sort\nvoid bubbleSort(int arr[], int n)\n{\n     int i, j, temp;\n     for (i = 0; i < n - 1; i++)\n     {\n          for (j = 0; j < n - i - 1; j++)\n          {\n               if (arr[j] > arr[j + 1])\n               {\n                    // Swap arr[j] and arr[j+1]\n                    temp = arr[j];\n                    arr[j] = arr[j + 1];\n                    arr[j + 1] = temp;\n               }\n          }\n     }\n}\n\n// Function to print the array\nvoid printArray(int arr[], int n)\n{\n     int i;\n     printf(\"Sorted array: \");\n     for (i = 0; i < n; i++)\n          printf(\"%d \", arr[i]);\n     printf(\"\\n\");\n}\n\nvoid main()\n{\n     int arr[MAX], n, i;\n\n     clrscr(); // Clear the screen\n\n     // Input number of elements\n     printf(\"Enter the number of elements: \");\n     scanf(\"%d\", &n);\n\n     // Input elements\n     printf(\"Enter %d elements:\\n\", n);\n     for (i = 0; i < n; i++)\n     {\n          printf(\"Element %d: \", i + 1);\n          scanf(\"%d\", &arr[i]);\n     }\n\n     // Perform bubble sort\n     bubbleSort(arr, n);\n\n     // Print the sorted array\n     printArray(arr, n);\n\n     getch(); // Wait for a key press\n}
`,
        },
      ],
    },
    {
      slipId: 7,
      questions: [
        {
          questionId: 1,
          text: `Write menu driven program using ‘C’ for Binary Search Tree.<br> The menu includes:<br> - Create a Binary Search Tree<br> - Display<br> - Delete a given element from Binary Search Tree`,
          marks: 20,
          sol: `#include<stdio.h>\n#include<conio.h>\n#include<stdlib.h>\n\nstruct Node\n{\n     int data;\n     struct Node *left;\n     struct Node *right;\n};\ntypedef struct Node Node;\n\n// Function to create a new node\nNode *createNode(int data)\n{\n     Node *newNode = (Node *)malloc(sizeof(Node));\n     newNode->data = data;\n     newNode->left = NULL;\n     newNode->right = NULL;\n     return newNode;\n}\n\n// Function to insert a node into the BST\nNode *insert(Node *root, int data)\n{\n     if (root == NULL)\n     {\n          return createNode(data);\n     }\n     if (data < root->data)\n     {\n          root->left = insert(root->left, data);\n     }\n     else\n     {\n          root->right = insert(root->right, data);\n     }\n     return root;\n}\n\n// Function to find the minimum value node in the subtree\nNode *findMin(Node *root)\n{\n     while (root->left != NULL)\n     {\n          root = root->left;\n     }\n     return root;\n}\n\n// Function to delete a node from the BST\nNode *deleteNode(Node *root, int data)\n{\n     if (root == NULL)\n     {\n          return NULL;\n     }\n     if (data < root->data)\n     {\n          root->left = deleteNode(root->left, data);\n     }\n     else if (data > root->data)\n     {\n          root->right = deleteNode(root->right, data);\n     }\n     else\n     {\n          // Node with the data found\n          if (root->left == NULL)\n          {\n               Node *temp = root->right;\n               free(root);\n               return temp;\n          }\n          else if (root->right == NULL)\n          {\n               Node *temp = root->left;\n               free(root);\n               return temp;\n          }\n          Node *temp = findMin(root->right);\n          root->data = temp->data;\n          root->right = deleteNode(root->right, temp->data);\n     }\n     return root;\n}\n\n// Function to perform in-order traversal and display the BST\nvoid inorder(Node *root)\n{\n     if (root != NULL)\n     {\n          inorder(root->left);\n          printf(\"%d \", root->data);\n          inorder(root->right);\n     }\n}\n\nvoid main()\n{\n     Node *root = NULL;\n     int choice, data;\n\n     clrscr(); // Clear the screen\n\n     while (1)\n     {\n          printf(\"\\nMenu:\");\n          printf(\"\\n1. Create Binary Search Tree\");\n          printf(\"\\n2. Display Binary Search Tree (In-Order Traversal)\");\n          printf(\"\\n3. Delete a Given Element from Binary Search Tree\");\n          printf(\"\\n4. Exit\");\n          printf(\"\\nEnter your choice: \");\n          scanf(\"%d\", &choice);\n\n          switch (choice)\n          {\n          case 1:\n               printf(\"\\nEnter the data to be inserted into the BST: \");\n               scanf(\"%d\", &data);\n               root = insert(root, data);\n               break;\n          case 2:\n               printf(\"\\nBinary Search Tree (In-Order Traversal): \");\n               inorder(root);\n               printf(\"\\n\");\n               break;\n          case 3:\n               printf(\"\\nEnter the data to be deleted from the BST: \");\n               scanf(\"%d\", &data);\n               root = deleteNode(root, data);\n               break;\n          case 4:\n               exit(0);\n          default:\n               printf(\"\\nInvalid choice! Please enter a valid option.\");\n          }\n     }\n\n     getch(); // Wait for a key press\n}
`,
        },
        {
          questionId: 2,
          text: `Write a ‘C’ program to create a singly linked list and count total number of nodes in it and display the list and total number of Nodes.`,
          marks: 10,
          sol: `#include<stdio.h>\n#include<conio.h>\n#include<stdlib.h>\n\nstruct NODE\n{\n     int data;          // Node data\n     struct NODE *next; // Pointer to next node\n};\n\ntypedef struct NODE node;\nnode *list = NULL, *last; // Initialize list and last pointers\n\n// Create a new node\nnode *getnode()\n{\n     node *temp;\n     temp = (node *)malloc(sizeof(node)); // Allocate memory\n     printf(\"\\nEnter the data: \");\n     scanf(\"%d\", &temp->data); // Read node data\n     temp->next = NULL;        // Initialize next pointer\n     return temp;\n}\n\n// Create linked list with n nodes\nvoid create()\n{\n     int n, i;\n     node *temp;\n     printf(\"\\nEnter total nodes to be created: \");\n     scanf(\"%d\", &n); // Read number of nodes\n\n     for (i = 0; i < n; i++)\n     {\n          temp = getnode(); // Get new node\n          if (list == NULL)\n               list = temp; // Set as first node\n          else\n               last->next = temp; // Append to last node\n          last = temp;            // Update last node\n     }\n}\n\n// Display all nodes in the list\nvoid display()\n{\n     node *ptr;\n     for (ptr = list; ptr != NULL; ptr = ptr->next)\n          printf(\"\\t%d\", ptr->data); // Print node data\n}\n\n// Count the number of nodes in the list\nvoid count()\n{\n     node *ptr;\n     int cnt;\n     for (ptr = list, cnt = 0; ptr != NULL; ptr = ptr->next, cnt++)\n          ;\n     printf(\"\\nTotal no of Nodes = %d\", cnt); // Print total count\n}\n\nvoid main()\n{\n     clrscr();  // Clear screen\n     create();  // Create linked list\n     display(); // Display list\n     count();   // Display node count\n     getch();   // Wait for user input\n}
`,
        },
      ],
    },
    {
      slipId: 8,
      questions: [
        {
          questionId: 1,
          text: `Write menu driven program using ‘C’ for Binary Search Tree.<br> The menu includes:<br> - Create a Binary Search Tree<br> - Display<br> - Search the element in Binary Search Tree`,
          marks: 20,
          sol: `#include<stdio.h>\n#include<conio.h>\n#include<stdlib.h>\n\nstruct NODE\n{\n     struct NODE *lchild; // Pointer to left child\n     int data;            // Node data\n     struct NODE *rchild; // Pointer to right child\n};\n\ntypedef struct NODE node;\n\n// Create a new node\nnode *getnode()\n{\n     node *temp;\n     temp = (node *)malloc(sizeof(node)); // Allocate memory\n     printf(\"\\nEnter the data: \");\n     scanf(\"%d\", &temp->data); // Read node data\n     temp->lchild = NULL;      // Initialize left child\n     temp->rchild = NULL;      // Initialize right child\n     return temp;\n}\n\n// Create a Binary Search Tree (BST)\nnode *create()\n{\n     int ch;\n     node *root, *temp, *ptr;\n     root = NULL;\n     do\n     {\n          temp = getnode(); // Create new node\n          if (root == NULL)\n               root = temp; // Set as root if tree is empty\n          else\n          {\n               ptr = root;\n               while (ptr != NULL)\n               {\n                    if (temp->data < ptr->data)\n                    { // Insert in left subtree\n                         if (ptr->lchild == NULL)\n                         {\n                              ptr->lchild = temp;\n                              break;\n                         }\n                         else\n                              ptr = ptr->lchild;\n                    }\n                    else\n                    { // Insert in right subtree\n                         if (ptr->rchild == NULL)\n                         {\n                              ptr->rchild = temp;\n                              break;\n                         }\n                         else\n                              ptr = ptr->rchild;\n                    }\n               }\n          }\n          printf(\"\\nDo you want to add more node (Y/N): \");\n          ch = getche(); // Read user choice\n     } while (ch == 'Y' || ch == 'y');\n     return root;\n}\n\n// Display BST in inorder (left-root-right) traversal\nvoid display(node *ptr)\n{\n     if (ptr != NULL)\n     {\n          display(ptr->lchild);     // Visit left subtree\n          printf(\" %d\", ptr->data); // Print node data\n          display(ptr->rchild);     // Visit right subtree\n     }\n}\n\n// Search for a value in BST\nint search(node *ptr, int val)\n{\n     while (ptr != NULL)\n     {\n          if (ptr->data == val)\n               return 1; // Value found\n          if (val < ptr->data)\n               ptr = ptr->lchild; // Search left subtree\n          else\n               ptr = ptr->rchild; // Search right subtree\n     }\n     return 0; // Value not found\n}\n\nvoid main()\n{\n     int ch, val, resp;\n     node *root = NULL;\n     clrscr(); // Clear screen\n     while (1)\n     {\n          printf(\"\\n1: Create a BST.\");\n          printf(\"\\n2: Display\");\n          printf(\"\\n3: Search\");\n          printf(\"\\n4: Exit\");\n          printf(\"\\nEnter the Choice: \");\n          scanf(\"%d\", &ch);\n          switch (ch)\n          {\n          case 1:\n               root = create(); // Create BST\n               break;\n          case 2:\n               display(root); // Display BST\n               break;\n          case 3:\n               printf(\"\\nEnter the value to search: \");\n               scanf(\"%d\", &val);\n               resp = search(root, val); // Search for value\n               if (resp == 1)\n                    printf(\"\\nValue is found in Tree.\");\n               else\n                    printf(\"\\nValue not found in Tree.\");\n               break;\n          case 4:\n               exit(0); // Exit program\n          }\n     }\n     getch(); // Wait for user input\n}
`,
        },
        {
          questionId: 2,
          text: `Write a ‘C’ program to accept and sort n elements in ascending order by using insertion sort.`,
          marks: 10,
          sol: `#include<stdio.h>\n#include<conio.h>\n\nvoid insertionSort(int arr[], int n)\n{\n     int i, key, j;\n     for (i = 1; i < n; i++)\n     {\n          key = arr[i];\n          j = i - 1;\n\n          // Move elements of arr[0..i-1], that are greater than key,\n          // to one position ahead of their current position\n          while (j >= 0 && arr[j] > key)\n          {\n               arr[j + 1] = arr[j];\n               j = j - 1;\n          }\n          arr[j + 1] = key;\n     }\n}\n\nvoid main()\n{\n     int n, i;\n\n     clrscr(); // Clear the screen\n\n     printf(\"Enter the number of elements: \");\n     scanf(\"%d\", &n);\n\n     int arr[n];\n\n     printf(\"Enter %d elements:\\n\", n);\n     for (i = 0; i < n; i++)\n     {\n          printf(\"Element %d: \", i + 1);\n          scanf(\"%d\", &arr[i]);\n     }\n\n     insertionSort(arr, n);\n\n     printf(\"Sorted array in ascending order:\\n\");\n     for (i = 0; i < n; i++)\n     {\n          printf(\"%d \", arr[i]);\n     }\n     printf(\"\\n\");\n\n     getch(); // Wait for a key press\n}
`,
        },
      ],
    },
    {
      slipId: 9,
      questions: [
        {
          questionId: 1,
          text: `Write a program to accept a postfix expression and evaluate the expression using the stack.<br> Example: Input: ab+cd-*<br> Values: a=4, b=2, c=5, d=3<br> Answer: 12`,
          marks: 20,
          sol: `#include<stdio.h>\n#include<conio.h>\n#include<math.h> // Required for pow function\n\n#define MAX 30\n\nstruct STACK\n{\n     double stk[MAX]; // Array to hold stack elements\n     int top;         // Index of the top element\n};\ntypedef struct STACK stack;\n\n// Initialize the stack\nvoid initstack(stack *s)\n{\n     int i;\n     for (i = 0; i < MAX; i++)\n          s->stk[i] = 0; // Set all elements to 0\n     s->top = -1;        // Set top to -1 indicating an empty stack\n}\n\n// Check if the stack is empty\nint isempty(stack *s)\n{\n     return s->top == -1; // Return 1 if stack is empty\n}\n\n// Check if the stack is full\nint isfull(stack *s)\n{\n     return s->top == MAX - 1; // Return 1 if stack is full\n}\n\n// Push data onto the stack\nvoid push(stack *s, double data)\n{\n     if (!isfull(s))\n     {\n          s->stk[++s->top] = data; // Increment top and add data\n     }\n}\n\n// Pop data from the stack\ndouble pop(stack *s)\n{\n     if (!isempty(s))\n     {\n          return s->stk[s->top--]; // Return top element and decrement top\n     }\n     return 0; // Return 0 if stack is empty (error handling)\n}\n\n// Display stack elements\nvoid display(stack *s)\n{\n     int i;\n     printf(\"\\nStack: \");\n     for (i = 0; i <= s->top; i++)\n          printf(\"\\t%f\", s->stk[i]); // Print each element\n}\n\n// Check if a character is a digit\nint isdigit(char symb)\n{\n     return symb >= '0' && symb <= '9'; // Return 1 if character is a digit\n}\n\n// Evaluate an expression with two operands and an operator\ndouble eval(double opnd1, double opnd2, char symb)\n{\n     switch (symb)\n     {\n     case '+':\n          return opnd1 + opnd2;\n     case '-':\n          return opnd1 - opnd2;\n     case '*':\n          return opnd1 * opnd2;\n     case '/':\n          return opnd1 / opnd2;\n     case '^':\n          return pow(opnd1, opnd2); // Use pow for exponentiation\n     default:\n          return 0; // Default case for unknown operators\n     }\n}\n\n// Check if a character is an operator\nint isoperator(char symbol)\n{\n     return symbol == '+' || symbol == '-' || symbol == '*' || symbol == '/' || symbol == '^';\n}\n\n// Convert expression from variables to digits\nchar *convert(char *expr)\n{\n     int i, j, scnt = 0, symval[10], flag = 0;\n     char symbol[10];\n\n     // Initialize first symbol\n     symbol[scnt++] = expr[0];\n     printf(\"\\nEnter the Value of %c: \", expr[0]);\n     scanf(\"%d\", &symval[0]);\n     expr[0] = symval[0] + 48; // Convert to ASCII character\n\n     for (i = 1; expr[i] != '\\0'; i++)\n     {\n          flag = 0;\n          if (!isoperator(expr[i]))\n          { // Process non-operator characters\n               for (j = 0; j < scnt; j++)\n               {\n                    if (expr[i] == symbol[j])\n                    {\n                         flag = 1;\n                         expr[i] = symval[j] + 48; // Convert to ASCII character\n                         break;\n                    }\n               }\n               if (!flag)\n               { // New symbol\n                    symbol[scnt] = expr[i];\n                    printf(\"\\nEnter the Value of %c: \", expr[i]);\n                    scanf(\"%d\", &symval[scnt]);\n                    expr[i] = symval[scnt] + 48; // Convert to ASCII character\n                    scnt++;\n               }\n          }\n     }\n     printf(\"\\n Expression after converting into digit form=%s\", expr);\n     return expr;\n}\n\n// Evaluate postfix expression\ndouble posteval(char *expr)\n{\n     stack s;\n     int i;\n     double opnd1, opnd2, result;\n\n     initstack(&s);\n     expr = convert(expr); // Convert variables to digits\n\n     for (i = 0; expr[i] != '\\0'; i++)\n     {\n          if (isdigit(expr[i]))\n          {\n               push(&s, expr[i] - 48); // Push digit onto stack\n          }\n          else\n          {\n               opnd2 = pop(&s);                      // Pop second operand\n               opnd1 = pop(&s);                      // Pop first operand\n               result = eval(opnd1, opnd2, expr[i]); // Evaluate\n               push(&s, result);                     // Push result back onto stack\n          }\n     }\n     return pop(&s); // Return final result\n}\n\nvoid main()\n{\n     char expr[MAX];\n     clrscr(); // Clear screen\n     printf(\"\\nEnter the Expression: \");\n     scanf(\" %s\", expr);                                             // Read postfix expression\n     printf(\"\\nResult after postfix Evaluation=%f\", posteval(expr)); // Print result\n     getch();                                                        // Wait for user input\n}`,
        },
        {
          questionId: 2,
          text: `Write a ‘C’ program to create a singly linked list, reverse it and display both the list.`,
          marks: 10,
          sol: `#include<stdio.h>\n#include<conio.h>\n\nstruct NODE\n{\n     int data;\n     struct NODE *next;\n};\n\ntypedef struct NODE node;\n\nnode *list = NULL, *last;\n\nnode *getnode() // Create a node\n{\n     node *temp;\n     temp = (node *)malloc(sizeof(node)); // Allocate memory for a new node\n     printf(\"\\nEnter the data: \");\n     scanf(\"%d\", &temp->data); // Input data for the node\n     temp->next = NULL;        // Initialize next pointer to NULL\n     return temp;              // Return the new node\n}\n\nvoid create()\n{\n     int n, i;\n     node *temp;\n\n     printf(\"\\nEnter total nodes to be created: \");\n     scanf(\"%d\", &n); // Input number of nodes\n     for (i = 0; i < n; i++)\n     {\n          temp = getnode(); // Create a new node\n          if (list == NULL) // If list is empty, set the first node\n               list = temp;\n          else\n               last->next = temp; // Link new node to the end of the list\n          last = temp;            // Update last pointer\n     }\n}\n\nvoid display(node *list)\n{\n     node *ptr;\n     for (ptr = list; ptr != NULL; ptr = ptr->next)\n          printf(\"%d->\", ptr->data); // Print each node's data\n     printf(\"NULL\");                 // End of the list\n}\n\nnode *reverse() // Reverse the linked list\n{\n     node *ptr, *prev, *revlist = NULL;\n\n     while (list != NULL)\n     {\n          for (ptr = list, prev = list; ptr->next != NULL; prev = ptr, ptr = ptr->next)\n               ;                           // Traverse to the last node in the list\n          if (ptr == list && prev == list) // If only one node exists\n               list = NULL;\n          prev->next = NULL; // Break the link\n          if (revlist == NULL)\n               revlist = ptr; // Initialize reversed list with last node\n          else\n               last->next = ptr; // Add node to the reversed list\n          last = ptr;            // Update last pointer\n     }\n     return revlist; // Return the head of the reversed list\n}\n\nvoid main()\n{\n     int ch, val;\n     node *revlist;\n\n     clrscr();\n\n     create();            // Create the list\n     display(list);       // Display the original list\n     revlist = reverse(); // Reverse the list\n     printf(\"\\nList after reversing: \");\n     display(revlist); // Display the reversed list\n\n     printf(\"\\nOriginal list: \");\n     display(list); // Display the original list (should be empty)\n\n     getch(); // Wait for key press\n}
`,
        },
      ],
    },
    {
      slipId: 10,
      questions: [
        {
          questionId: 1,
          text: `Write a ‘C’ program to read ‘n’ integers and store them in a Binary search tree and display the nodes level wise.`,
          marks: 20,
          sol: `#include<stdio.h>\n#include<conio.h>\n#include<stdlib.h>\n\n#define MAX 100\n\n// Define the structure for a node in the BST\nstruct Node\n{\n     int data;\n     struct Node *left;\n     struct Node *right;\n};\n\n// Define a node\ntypedef struct Node Node;\n\n// Function to create a new node\nNode *createNode(int data)\n{\n     Node *newNode = (Node *)malloc(sizeof(Node));\n     newNode->data = data;\n     newNode->left = NULL;\n     newNode->right = NULL;\n     return newNode;\n}\n\n// Function to insert a node in the BST\nNode *insertNode(Node *root, int data)\n{\n     if (root == NULL)\n     {\n          return createNode(data);\n     }\n     if (data < root->data)\n     {\n          root->left = insertNode(root->left, data);\n     }\n     else\n     {\n          root->right = insertNode(root->right, data);\n     }\n     return root;\n}\n\n// Function to print nodes level-wise\nvoid printLevelOrder(Node *root)\n{\n     if (root == NULL)\n          return;\n\n     Node *queue[MAX];\n     int front = 0, rear = 0;\n     queue[rear++] = root;\n\n     while (front < rear)\n     {\n          Node *current = queue[front++];\n          printf(\"%d \", current->data);\n\n          if (current->left != NULL)\n          {\n               queue[rear++] = current->left;\n          }\n          if (current->right != NULL)\n          {\n               queue[rear++] = current->right;\n          }\n     }\n}\n\n// Main function\nvoid main()\n{\n     Node *root = NULL;\n     int n, i, data;\n\n     clrscr(); // Clear the screen\n\n     printf(\"Enter the number of elements: \");\n     scanf(\"%d\", &n);\n\n     printf(\"Enter %d integers:\\n\", n);\n     for (i = 0; i < n; i++)\n     {\n          printf(\"Element %d: \", i + 1);\n          scanf(\"%d\", &data);\n          root = insertNode(root, data);\n     }\n\n     printf(\"Nodes in level order:\\n\");\n     printLevelOrder(root);\n\n     getch(); // Wait for a key press\n}
`,
        },
        {
          questionId: 2,
          text: `Write a ‘C’ program to sort randomly generated array elements using Insertion sort method.<br> (Use Random Function)`,
          marks: 10,
          sol: `#include<stdio.h>\n#include<conio.h>\n#include<stdlib.h>\n#include<time.h>\n\n#define MAX 100\n\n// Function to perform insertion sort\nvoid insertionSort(int arr[], int n)\n{\n     int i, j, key;\n     for (i = 1; i < n; i++)\n     {\n          key = arr[i];\n          j = i - 1;\n\n          // Move elements of arr[0..i-1] that are greater than key\n          // to one position ahead of their current position\n          while (j >= 0 && arr[j] > key)\n          {\n               arr[j + 1] = arr[j];\n               j = j - 1;\n          }\n          arr[j + 1] = key;\n     }\n}\n\n// Function to print the array\nvoid printArray(int arr[], int n)\n{\n     int i;\n     for (i = 0; i < n; i++)\n     {\n          printf(\"%d \", arr[i]);\n     }\n     printf(\"\\n\");\n}\n\n// Main function\nvoid main()\n{\n     int arr[MAX];\n     int n, i;\n\n     clrscr(); // Clear the screen\n\n     // Seed the random number generator\n     srand(time(0));\n\n     printf(\"Enter the number of elements: \");\n     scanf(\"%d\", &n);\n\n     // Generate random numbers and store them in the array\n     for (i = 0; i < n; i++)\n     {\n          arr[i] = rand() % 100; // Generate random number between 0 and 99\n     }\n\n     printf(\"Original array:\\n\");\n     printArray(arr, n);\n\n     // Sort the array using insertion sort\n     insertionSort(arr, n);\n\n     printf(\"Sorted array:\\n\");\n     printArray(arr, n);\n\n     getch(); // Wait for a key press\n}
`,
        },
      ],
    },
    {
      slipId: 11,
      questions: [
        {
          questionId: 1,
          text: `Write a menu driven program using ‘C’ for singly linked list:<br> - To create linked list.<br> - To display linked list<br> - To search node in linked list.<br> - Insert at last position`,
          marks: 20,
          sol: `#include<stdio.h>\n#include<conio.h>\n\nstruct NODE\n{\n     int data;\n     struct NODE *next;\n};\n\ntypedef struct NODE node;\n\nnode *list = NULL, *last;\n\nnode *getnode() // Create a new node\n{\n     node *temp;\n     temp = (node *)malloc(sizeof(node)); // Allocate memory for a new node\n     printf(\"\\nEnter the data: \");\n     scanf(\"%d\", &temp->data); // Input data for the node\n     temp->next = NULL;        // Initialize next pointer to NULL\n     return temp;              // Return the new node\n}\n\nvoid create()\n{\n     int n, i;\n     node *temp;\n\n     printf(\"\\nEnter total nodes to be created: \");\n     scanf(\"%d\", &n); // Input number of nodes\n     for (i = 0; i < n; i++)\n     {\n          temp = getnode(); // Create a new node\n          if (list == NULL) // If list is empty, set the first node\n               list = temp;\n          else\n               last->next = temp; // Link new node to the end of the list\n          last = temp;            // Update last pointer\n     }\n}\n\nvoid display() // Display the linked list\n{\n     node *ptr;\n     for (ptr = list; ptr != NULL; ptr = ptr->next)\n          printf(\"\\t%d\", ptr->data); // Print each node's data\n}\n\nvoid search(int val) // Search for a value in the linked list\n{\n     node *ptr;\n     int pos;\n     for (ptr = list, pos = 1; ptr != NULL && ptr->data != val; ptr = ptr->next, pos++)\n          ; // Traverse the list to find the value\n     if (ptr != NULL && ptr->data == val)\n          printf(\"Value is found in LL at %d position.\", pos); // Value found\n     else\n          printf(\"Value not found.\"); // Value not found\n}\n\nvoid insertend() // Insert a new node at the end of the list\n{\n     node *temp;\n     temp = getnode();  // Create a new node\n     last->next = temp; // Link new node to the end of the list\n     last = temp;       // Update last pointer\n}\n\nvoid main()\n{\n     int ch, val;\n     clrscr();\n\n     while (1)\n     {\n          printf(\"\\n1: Create the Linked list.\");\n          printf(\"\\n2: Display the Linked List.\");\n          printf(\"\\n3: Search.\");\n          printf(\"\\n4: Insert at Last Position.\");\n          printf(\"\\n5: Exit.\");\n          printf(\"\\nEnter the choice: \");\n          scanf(\"%d\", &ch);\n          switch (ch)\n          {\n          case 1:\n               create(); // Create the list\n               break;\n          case 2:\n               display(); // Display the list\n               break;\n          case 3:\n               printf(\"\\nEnter the value to be searched: \");\n               scanf(\"%d\", &val);\n               search(val); // Search for a value\n               break;\n          case 4:\n               insertend(); // Insert at the end\n               break;\n          case 5:\n               exit(0); // Exit the program\n          }\n     }\n     getch(); // Wait for key press\n}
`,
        },
        {
          questionId: 2,
          text: `Write a menu driven program using ‘C’ for Dynamic implementation of Queue for integers. The menu includes:<br> - Insert<br> - Delete<br> - Display<br> - Exit`,
          marks: 10,
          sol: `#include<stdio.h>\n#include<conio.h>\n\nstruct NODE\n{\n     int data;\n     struct NODE *next;\n};\n\ntypedef struct NODE node;\n\nnode *front = NULL, *rear = NULL;\n\nint isempty() // Check if the queue is empty\n{\n     if (front == NULL && rear == NULL)\n          return 1; // Queue is empty\n     else\n          return 0; // Queue is not empty\n}\n\nnode *getnodenum(int data) // Create a new node with given data\n{\n     node *temp;\n     temp = (node *)malloc(sizeof(node)); // Allocate memory for the node\n     temp->data = data;                   // Set the data for the node\n     temp->next = NULL;                   // Initialize next pointer to NULL\n     return temp;                         // Return the new node\n}\n\nvoid add(int data) // Add a new node to the end of the queue\n{\n     node *temp;\n     temp = getnodenum(data); // Create a new node\n     if (front == NULL)       // If the queue is empty\n     {\n          rear = temp; // Set both front and rear to the new node\n          front = temp;\n     }\n     else\n     {\n          rear->next = temp; // Link the new node to the end of the queue\n          rear = temp;       // Update the rear to the new node\n     }\n}\n\nint deleteq() // Remove and return the front node's data from the queue\n{\n     node *ptr;\n     int val;\n     ptr = front;              // Point to the front node\n     val = front->data;        // Store the data of the front node\n     if (front->next != NULL)  // If there are more nodes in the queue\n          front = front->next; // Update front to the next node\n     else\n     {\n          front = NULL; // Queue is empty now\n          rear = NULL;  // Clear rear pointer\n     }\n     free(ptr);  // Free the memory of the removed node\n     return val; // Return the data of the removed node\n}\n\nvoid display() // Display all the nodes in the queue\n{\n     node *ptr;\n     for (ptr = front; ptr != rear; ptr = ptr->next)\n          printf(\" %d\", ptr->data); // Print each node's data\n     printf(\" %d\", ptr->data);      // Print the last node's data\n}\n\nvoid main()\n{\n     int ch, data;\n     clrscr(); // Clear the screen\n\n     while (1)\n     {\n          printf(\"\\n1: Add.\");\n          printf(\"\\n2: Delete\");\n          printf(\"\\n3: Display.\");\n          printf(\"\\n4: Exit\");\n\n          printf(\"\\nEnter the Choice: \");\n          scanf(\"%d\", &ch); // Input the user's choice\n          switch (ch)\n          {\n          case 1:\n               printf(\"\\nEnter the data to insert in queue: \");\n               scanf(\"%d\", &data);\n               add(data); // Add data to the queue\n               break;\n          case 2:\n               if (isempty())\n                    printf(\"\\nQueue is Empty!\");\n               else\n                    printf(\"\\nDeleted element is: %d\", deleteq()); // Delete and show the front element\n               break;\n          case 3:\n               if (isempty())\n                    printf(\"\\nQueue is Empty!\");\n               else\n                    display(); // Display the queue\n               break;\n          case 4:\n               exit(1); // Exit the program\n          }\n     }\n     getch(); // Wait for key press\n}
`,
        },
      ],
    },
    {
      slipId: 12,
      questions: [
        {
          questionId: 1,
          text: `Write a C program that accepts the graph as an adjacency matrix and checks if the graph is undirected. The matrix for undirected graph is symmetric. Also calculate in-degree of all vertices:<br> - Read a graph as adjacency Matrix<br> - Check the matrix is symmetric or not<br> - Calculate indegree of all vertices`,
          marks: 20,
          sol: `#include<stdio.h>\n#include<conio.h>\n\n#define MAX 10\n\n// Function to check if the matrix is symmetric\nint isSymmetric(int matrix[MAX][MAX], int n)\n{\n     int i, j;\n     for (i = 0; i < n; i++)\n     {\n          for (j = 0; j < n; j++)\n          {\n               if (matrix[i][j] != matrix[j][i])\n               {\n                    return 0; // Matrix is not symmetric\n               }\n          }\n     }\n     return 1; // Matrix is symmetric\n}\n\n// Function to calculate the in-degree of each vertex\nvoid calculateInDegrees(int matrix[MAX][MAX], int n)\n{\n     int i, j;\n     printf(\"\\nIn-degrees of all vertices:\\n\");\n     for (i = 0; i < n; i++)\n     {\n          int inDegree = 0;\n          for (j = 0; j < n; j++)\n          {\n               if (matrix[j][i] == 1)\n               {\n                    inDegree++;\n               }\n          }\n          printf(\"Vertex %d: %d\\n\", i, inDegree);\n     }\n}\n\n// Main function\nvoid main()\n{\n     int matrix[MAX][MAX];\n     int n, i, j;\n\n     clrscr(); // Clear the screen\n\n     printf(\"Enter the number of vertices: \");\n     scanf(\"%d\", &n);\n\n     // Input adjacency matrix\n     printf(\"Enter the adjacency matrix (%d x %d):\\n\", n, n);\n     for (i = 0; i < n; i++)\n     {\n          for (j = 0; j < n; j++)\n          {\n               printf(\"Matrix[%d][%d]: \", i, j);\n               scanf(\"%d\", &matrix[i][j]);\n          }\n     }\n\n     // Check if the matrix is symmetric\n     if (isSymmetric(matrix, n))\n     {\n          printf(\"\\nThe graph is undirected.\\n\");\n     }\n     else\n     {\n          printf(\"\\nThe graph is directed.\\n\");\n     }\n\n     // Calculate in-degrees of all vertices\n     calculateInDegrees(matrix, n);\n\n     getch(); // Wait for a key press\n}
`,
        },
        {
          questionId: 2,
          text: `Write a ‘C’ program to accept and sort n elements in ascending order using Selection sort method.`,
          marks: 10,
          sol: `#include<stdio.h>\n#include<conio.h>\n\n#define MAX 100\n\n// Function to perform selection sort\nvoid selectionSort(int arr[], int n)\n{\n     int i, j, minIndex, temp;\n\n     for (i = 0; i < n - 1; i++)\n     {\n          // Find the minimum element in unsorted part of array\n          minIndex = i;\n          for (j = i + 1; j < n; j++)\n          {\n               if (arr[j] < arr[minIndex])\n               {\n                    minIndex = j;\n               }\n          }\n\n          // Swap the found minimum element with the first element of the unsorted part\n          if (minIndex != i)\n          {\n               temp = arr[i];\n               arr[i] = arr[minIndex];\n               arr[minIndex] = temp;\n          }\n     }\n}\n\n// Main function\nvoid main()\n{\n     int arr[MAX];\n     int n, i;\n\n     clrscr(); // Clear the screen\n\n     printf(\"Enter the number of elements: \");\n     scanf(\"%d\", &n);\n\n     printf(\"Enter %d elements:\\n\", n);\n     for (i = 0; i < n; i++)\n     {\n          printf(\"Element %d: \", i + 1);\n          scanf(\"%d\", &arr[i]);\n     }\n\n     // Call selection sort\n     selectionSort(arr, n);\n\n     // Display the sorted array\n     printf(\"\\nSorted array in ascending order:\\n\");\n     for (i = 0; i < n; i++)\n     {\n          printf(\"%d \", arr[i]);\n     }\n\n     getch(); // Wait for a key press\n}
`,
        },
      ],
    },
    {
      slipId: 13,
      questions: [
        {
          questionId: 1,
          text: `Write a C program to accept an infix expression and convert it into postfix form.<br> (Use Static Implementation of Stack)<br> Example: - A * B + C as AB*C+`,
          marks: 20,
          sol: `#include<stdio.h>\n#include<conio.h>\n\n#define MAX 50\n\nstruct STACK\n{\n     char stk[MAX];\n     int top;\n};\n\ntypedef struct STACK stack;\n\n// Initialize the stack\nvoid initstack(stack *s)\n{\n     s->top = -1; // Stack is empty when top is -1\n}\n\nint isempty(stack *s)\n{\n     if (s->top == -1)\n          return 1; // Stack is empty\n     else\n          return 0; // Stack is not empty\n}\n\nint isfull(stack *s)\n{\n     if (s->top == MAX - 1)\n          return 1; // Stack is full\n     else\n          return 0; // Stack is not full\n}\n\nvoid push(stack *s, char data)\n{\n     s->top++;              // Move the top index up\n     s->stk[s->top] = data; // Push the data onto the stack\n}\n\nchar pop(stack *s)\n{\n     char val;\n     val = s->stk[s->top]; // Get the top element\n     s->top--;             // Move the top index down\n     return val;           // Return the popped element\n}\n\nchar gettop(stack *s)\n{\n     return s->stk[s->top]; // Return the top element without removing it\n}\n\nvoid display(stack *s)\n{\n     int i;\n     // Display all elements in the stack\n     for (i = 0; i <= s->top; i++)\n          printf(\"%c\", s->stk[i]);\n}\n\nint isoperator(char symbol)\n{\n     // Check if the symbol is an operator\n     if (symbol == '+' || symbol == '-' || symbol == '*' || symbol == '/' || symbol == '^')\n          return 1; // It is an operator\n     else\n          return 0; // It is not an operator\n}\n\nint priority(char oper)\n{\n     // Determine the precedence of the operator\n     if (oper == '^')\n          return 4; // Highest precedence\n     else if (oper == '/' || oper == '*')\n          return 3; // Medium precedence\n     else if (oper == '+' || oper == '-')\n          return 2; // Lower precedence\n     else\n          return 1; // Default precedence\n}\n\nint checktop(char topsymb)\n{\n     // Check if the top symbol is a parenthesis\n     if (topsymb == '(' || topsymb == '{' || topsymb == '[')\n          return 1; // It is a parenthesis\n     else\n          return 0; // It is not a parenthesis\n}\n\nvoid inpostfix(char *E)\n{\n     int i, j = 0;\n     char symbol, postfix[MAX], topsymb;\n     stack s;\n     initstack(&s);\n\n     printf(\"Symbol postfix\\tstack\");\n     for (i = 0; E[i] != '\\0'; i++)\n     {\n          symbol = E[i];\n          if (symbol == '(' || symbol == '{' || symbol == '[')\n               push(&s, symbol); // Push opening parenthesis onto stack\n          else if (isoperator(symbol) == 1)\n          {\n               // Pop operators from stack with higher or equal precedence\n               while (!isempty(&s) && priority(gettop(&s)) >= priority(symbol))\n                    postfix[j++] = pop(&s);\n               push(&s, symbol); // Push the current operator onto stack\n          }\n          else if (symbol == ')' || symbol == '}' || symbol == ']')\n          {\n               // Pop operators until matching opening parenthesis\n               topsymb = pop(&s);\n               while (!checktop(topsymb))\n               {\n                    postfix[j++] = topsymb;\n                    topsymb = pop(&s);\n               }\n          }\n          else\n               postfix[j++] = symbol; // Directly append operands\n          postfix[j] = '\\0';\n          printf(\"\\n%c %s\\t\\t\", symbol, postfix);\n          display(&s);\n          getch();\n     }\n     while (!isempty(&s))\n     {\n          postfix[j++] = pop(&s); // Pop remaining operators from the stack\n          postfix[j] = '\\0';\n          printf(\"\\n%c %s\\t\\t\", symbol, postfix);\n          display(&s);\n     }\n\n     // Display the final postfix expression\n     printf(\"\\nPostfix Expression: %s\", postfix);\n}\n\nmain()\n{\n     char expr[MAX];\n     clrscr(); // Clear the screen\n     printf(\"\\nEnter the Infix Expression: \");\n     scanf(\" %s\", expr);\n     inpostfix(expr); // Convert infix to postfix\n     getch();         // Wait for key press\n}
`,
        },
        {
          questionId: 2,
          text: `Write a ‘C’ program to create doubly linked list and display nodes having odd value.`,
          marks: 10,
          sol: `#include<stdio.h>\n#include<conio.h>\n#include<stdlib.h>\n\nstruct NODE\n{\n     struct NODE *prev; // Pointer to the previous node\n     int data;          // Data of the node\n     struct NODE *next; // Pointer to the next node\n};\n\ntypedef struct NODE node;\n\nnode *list = NULL, *last; // Pointers for the start and end of the list\n\nnode *getnode()\n{\n     node *temp;\n     temp = (node *)malloc(sizeof(node)); // Allocate memory for a new node\n     printf(\"\\nEnter the data: \");\n     scanf(\"%d\", &temp->data); // Read data for the node\n     temp->prev = NULL;        // Initialize previous pointer\n     temp->next = NULL;        // Initialize next pointer\n     return temp;\n}\n\nvoid create()\n{\n     int n, i;\n     node *temp;\n     printf(\"\\nEnter total nodes: \");\n     scanf(\"%d\", &n); // Read the number of nodes to create\n\n     for (i = 0; i < n; i++)\n     {\n          temp = getnode(); // Get a new node\n          if (list == NULL)\n               list = temp; // Set the first node\n          else\n          {\n               last->next = temp; // Link previous last node to new node\n               temp->prev = last; // Set the previous pointer of new node\n          }\n          last = temp; // Update the last node to the new node\n     }\n}\n\nvoid display()\n{\n     node *ptr;\n     for (ptr = list; ptr != NULL; ptr = ptr->next)\n          printf(\"%d->\", ptr->data); // Print data of each node\n     printf(\"->NULL\");               // End of the list\n}\n\nvoid displayodd()\n{\n     node *ptr;\n     for (ptr = list; ptr != NULL; ptr = ptr->next)\n     {\n          if ((ptr->data % 2) != 0)\n               printf(\"%d->\", ptr->data); // Print odd data\n     }\n     printf(\"->NULL\"); // End of the list\n}\n\nvoid main()\n{\n     clrscr(); // Clear the screen\n     create(); // Create the doubly linked list\n     printf(\"\\nDoubly LL: \");\n     display(); // Display the entire list\n     printf(\"\\nOdd values in Doubly LL: \");\n     displayodd(); // Display only the odd values\n     getch();      // Wait for user input\n}
`,
        },
      ],
    },
    {
      slipId: 14,
      questions: [
        {
          questionId: 1,
          text: `Write a ‘C’ program to accept a string from user and reverse it using Dynamic implementation of Stack.`,
          marks: 20,
          sol: `#include<stdio.h>\n#include<stdlib.h>\n#include<conio.h>\n\n// Stack node structure\nstruct Node\n{\n     char data;\n     struct Node *next;\n};\n\n// Stack structure\nstruct Stack\n{\n     struct Node *top;\n};\n\n// Function to initialize the stack\nvoid initStack(struct Stack *stack)\n{\n     stack->top = NULL;\n}\n\n// Function to push an element onto the stack\nvoid push(struct Stack *stack, char data)\n{\n     struct Node *newNode = (struct Node *)malloc(sizeof(struct Node));\n     newNode->data = data;\n     newNode->next = stack->top;\n     stack->top = newNode;\n}\n\n// Function to pop an element from the stack\nchar pop(struct Stack *stack)\n{\n     if (stack->top == NULL)\n     {\n          printf(\"Stack underflow\\n\");\n          return '\\0'; // Return null character if stack is empty\n     }\n     struct Node *temp = stack->top;\n     char data = temp->data;\n     stack->top = stack->top->next;\n     free(temp);\n     return data;\n}\n\n// Function to check if the stack is empty\nint isEmpty(struct Stack *stack)\n{\n     return stack->top == NULL;\n}\n\n// Function to reverse the string using stack\nvoid reverseString(char *str)\n{\n     struct Stack stack;\n     initStack(&stack);\n\n     // Push all characters of the string onto the stack\n     for (int i = 0; str[i] != '\\0'; i++)\n     {\n          push(&stack, str[i]);\n     }\n\n     // Pop all characters from the stack and place them back into the string\n     int i = 0;\n     while (!isEmpty(&stack))\n     {\n          str[i++] = pop(&stack);\n     }\n     str[i] = '\\0'; // Null-terminate the reversed string\n}\n\n// Main function\nvoid main()\n{\n     char str[100];\n\n     clrscr(); // Clear the screen\n\n     printf(\"Enter a string: \");\n     gets(str); // Read the string from the user\n\n     reverseString(str);\n\n     printf(\"Reversed string: %s\\n\", str);\n\n     getch(); // Wait for a key press\n}
`,
        },
        {
          questionId: 2,
          text: `Write a ‘C’ program to accept names from the user and sort in alphabetical order using bubble sort:<br> - Accept n name<br> - Bubble sort Function<br> - Display`,
          marks: 10,
          sol: `#include<stdio.h>\n#include<conio.h>\n#include<string.h>\n\n#define MAX 50\n#define MAX_NAME_LENGTH 100\n\n// Function to perform Bubble Sort on an array of strings\nvoid bubbleSort(char names[][MAX_NAME_LENGTH], int n)\n{\n     int i, j;\n     char temp[MAX_NAME_LENGTH];\n\n     for (i = 0; i < n - 1; i++)\n     {\n          for (j = 0; j < n - i - 1; j++)\n          {\n               if (strcmp(names[j], names[j + 1]) > 0)\n               {\n                    // Swap names[j] and names[j+1]\n                    strcpy(temp, names[j]);\n                    strcpy(names[j], names[j + 1]);\n                    strcpy(names[j + 1], temp);\n               }\n          }\n     }\n}\n\n// Main function\nvoid main()\n{\n     char names[MAX][MAX_NAME_LENGTH];\n     int n, i;\n\n     clrscr(); // Clear the screen\n\n     printf(\"Enter the number of names: \");\n     scanf(\"%d\", &n);\n     getchar(); // To consume the newline character left by scanf\n\n     // Accept names from the user\n     for (i = 0; i < n; i++)\n     {\n          printf(\"Enter name %d: \", i + 1);\n          fgets(names[i], MAX_NAME_LENGTH, stdin);\n          // Remove newline character from the end of the string\n          names[i][strcspn(names[i], \"\\n\")] = '\\0';\n     }\n\n     // Sort names in alphabetical order\n     bubbleSort(names, n);\n\n     // Display sorted names\n     printf(\"\\nSorted names:\\n\");\n     for (i = 0; i < n; i++)\n     {\n          printf(\"%s\\n\", names[i]);\n     }\n\n     getch(); // Wait for a key press\n}
`,
        },
      ],
    },
    {
      slipId: 15,
      questions: [
        {
          questionId: 1,
          text: `Write a ‘C’ program to accept an infix expression, convert it into its equivalent postfix expression and display the result.<br> (Use Dynamic Implementation of Stack)`,
          marks: 20,
          sol: `#include<stdio.h>\n#include<stdlib.h>\n#include<conio.h>\n#include<ctype.h>\n\n#define MAX 100\n\n// Structure for stack\ntypedef struct\n{\n     char *data;\n     int top;\n     int capacity;\n} Stack;\n\n// Function to create a stack\nStack *createStack(int capacity)\n{\n     Stack *stack = (Stack *)malloc(sizeof(Stack));\n     stack->capacity = capacity;\n     stack->top = -1;\n     stack->data = (char *)malloc(stack->capacity * sizeof(char));\n     return stack;\n}\n\n// Function to check if the stack is empty\nint isEmpty(Stack *stack)\n{\n     return stack->top == -1;\n}\n\n// Function to check if the stack is full\nint isFull(Stack *stack)\n{\n     return stack->top == stack->capacity - 1;\n}\n\n// Function to push an element to the stack\nvoid push(Stack *stack, char item)\n{\n     if (isFull(stack))\n     {\n          printf(\"Stack overflow\\n\");\n          return;\n     }\n     stack->data[++stack->top] = item;\n}\n\n// Function to pop an element from the stack\nchar pop(Stack *stack)\n{\n     if (isEmpty(stack))\n     {\n          printf(\"Stack underflow\\n\");\n          return '\\0';\n     }\n     return stack->data[stack->top--];\n}\n\n// Function to get the top element of the stack without popping\nchar peek(Stack *stack)\n{\n     if (!isEmpty(stack))\n     {\n          return stack->data[stack->top];\n     }\n     return '\\0';\n}\n\n// Function to check the precedence of operators\nint precedence(char op)\n{\n     switch (op)\n     {\n     case '+':\n     case '-':\n          return 1;\n     case '*':\n     case '/':\n          return 2;\n     case '^':\n          return 3;\n     default:\n          return 0;\n     }\n}\n\n// Function to convert infix expression to postfix\nvoid infixToPostfix(char *infix, char *postfix)\n{\n     Stack *stack = createStack(MAX);\n     int i = 0, k = 0;\n\n     while (infix[i] != '\\0')\n     {\n          if (isalnum(infix[i]))\n          {\n               postfix[k++] = infix[i];\n          }\n          else if (infix[i] == '(')\n          {\n               push(stack, infix[i]);\n          }\n          else if (infix[i] == ')')\n          {\n               while (!isEmpty(stack) && peek(stack) != '(')\n               {\n                    postfix[k++] = pop(stack);\n               }\n               pop(stack); // Remove '(' from stack\n          }\n          else\n          { // Operator\n               while (!isEmpty(stack) && precedence(peek(stack)) >= precedence(infix[i]))\n               {\n                    postfix[k++] = pop(stack);\n               }\n               push(stack, infix[i]);\n          }\n          i++;\n     }\n\n     // Pop all remaining operators from the stack\n     while (!isEmpty(stack))\n     {\n          postfix[k++] = pop(stack);\n     }\n     postfix[k] = '\\0'; // Null terminate the postfix expression\n     free(stack->data);\n     free(stack);\n}\n\n// Main function\nvoid main()\n{\n     char infix[MAX], postfix[MAX];\n\n     clrscr(); // Clear the screen\n\n     printf(\"Enter the infix expression: \");\n     gets(infix); // Read the infix expression\n\n     infixToPostfix(infix, postfix);\n\n     printf(\"Postfix expression: %s\\n\", postfix);\n\n     getch(); // Wait for a key press\n}
`,
        },
        {
          questionId: 2,
          text: `Write menu driven program using ‘C’ for Dynamic implementation of Stack. The menu includes following operations:<br> - Push<br> - Pop<br> - Display<br> - Exit`,
          marks: 10,
          sol: `#include<stdio.h>\n#include<conio.h>\n#include<stdlib.h> // Required for malloc and free\n\nstruct NODE\n{\n     int data;          // Data of the node (integer)\n     struct NODE *next; // Pointer to the next node\n};\n\ntypedef struct NODE node;\n\nnode *top = NULL; // Top of the stack\n\n// Function to create a new node with given data\nnode *getnodenum(int data)\n{\n     node *temp;\n     temp = (node *)malloc(sizeof(node)); // Allocate memory for the new node\n     temp->data = data;                   // Set the data for the new node\n     temp->next = NULL;                   // Initialize the next pointer to NULL\n     return temp;                         // Return the newly created node\n}\n\n// Function to check if the stack is empty\nint isempty()\n{\n     return (top == NULL); // Return 1 if top is NULL (stack is empty), otherwise return 0\n}\n\n// Function to push a new integer onto the stack\nvoid push(int data)\n{\n     node *temp;\n     temp = getnodenum(data); // Create a new node with the given data\n     temp->next = top;        // Point the new node's next to the current top\n     top = temp;              // Update the top to the new node\n}\n\n// Function to pop an integer from the stack\nint pop()\n{\n     int val;\n     node *ptr;\n     ptr = top;       // Get the node at the top of the stack\n     val = ptr->data; // Retrieve the data from the top node\n     top = ptr->next; // Update the top to the next node\n     free(ptr);       // Free the memory of the old top node\n     return val;      // Return the data of the popped node\n}\n\n// Function to display all elements in the stack\nvoid display()\n{\n     node *ptr;\n     for (ptr = top; ptr != NULL; ptr = ptr->next) // Traverse the stack\n          printf(\"\\t%d\", ptr->data);               // Print each element\n}\n\n// Main function to interact with the stack\nvoid main()\n{\n     int ch, data;\n     clrscr(); // Clear the screen (Note: clrscr is specific to some compilers)\n\n     while (1) // Infinite loop to continuously show menu\n     {\n          printf(\"\\n1:PUSH.\");\n          printf(\"\\n2:POP.\");\n          printf(\"\\n3:Display.\");\n          printf(\"\\n4:Exit.\");\n          printf(\"\\nEnter the Choice:\");\n          scanf(\"%d\", &ch);\n\n          switch (ch)\n          {\n          case 1: // PUSH operation\n               printf(\"\\nEnter the data:\");\n               scanf(\"%d\", &data);\n               push(data); // Call push function to add data to the stack\n               break;\n\n          case 2: // POP operation\n               if (isempty())\n                    printf(\"\\nStack is empty.\"); // Check if stack is empty before popping\n               else\n                    printf(\"\\nPopped data from stack: %d\", pop()); // Call pop function to remove and print data\n               break;\n\n          case 3: // Display operation\n               if (isempty())\n                    printf(\"\\nStack is Empty.\"); // Check if stack is empty before displaying\n               else\n                    display(); // Call display function to print stack elements\n               break;\n\n          case 4:       // Exit operation\n               exit(0); // Exit the program\n          }\n     }\n\n     getch(); // Wait for user input (Note: getch is specific to some compilers)\n}
`,
        },
      ],
    },
    {
      slipId: 16,
      questions: [
        {
          questionId: 1,
          text: `Write a ‘C’ program which accept the string and reverse each word of the string using Static implementation of stack.<br> Example: Input - This is an input string<br> Output - sihTsi na tupnignirts`,
          marks: 20,
          sol: `#include<stdio.h>\n#include<conio.h>\n#include<stdlib.h> // Required for malloc and free\n\nstruct NODE\n{\n     char data;         // Data of the node (character)\n     struct NODE *next; // Pointer to the next node\n};\n\ntypedef struct NODE node;\n\nnode *top = NULL; // Top of the stack\n\n// Function to create a new node with given data\nnode *getnodenum(char data)\n{\n     node *temp;\n     temp = (node *)malloc(sizeof(node)); // Allocate memory for the new node\n     temp->data = data;                   // Set the data for the new node\n     temp->next = NULL;                   // Initialize the next pointer to NULL\n     return temp;                         // Return the newly created node\n}\n\n// Function to check if the stack is empty\nint isempty()\n{\n     return (top == NULL); // Return 1 if top is NULL (stack is empty), otherwise return 0\n}\n\n// Function to push a new character onto the stack\nvoid push(char data)\n{\n     node *temp;\n     temp = getnodenum(data); // Create a new node with the given data\n     temp->next = top;        // Point the new node's next to the current top\n     top = temp;              // Update the top to the new node\n}\n\n// Function to pop a character from the stack\nchar pop()\n{\n     char val;\n     node *ptr;\n     ptr = top;       // Get the node at the top of the stack\n     val = ptr->data; // Retrieve the data from the top node\n     top = ptr->next; // Update the top to the next node\n     free(ptr);       // Free the memory of the old top node\n     return val;      // Return the data of the popped node\n}\n\nvoid main()\n{\n     int i;\n     char string[50];\n     clrscr(); // Clear the screen\n     printf(\"\\nEnter the String: \");\n     gets(string); // Read a string from user (Note: gets is unsafe, consider using fgets)\n\n     // Push each character of the string onto the stack\n     for (i = 0; string[i] != '\\0'; i++)\n          push(string[i]);\n\n     printf(\"\\nReverse String:\");\n\n     // Pop each character from the stack to reverse the string\n     while (!isempty())\n          printf(\"%c\", pop());\n\n     getch(); // Wait for user input\n}
`,
        },
        {
          questionId: 2,
          text: `Write a ‘C’ program to create a Singly linked list. Accept the number from user, search the number in the list. If the number is present display the Position of node. If number not present print the message “Number not Found”.`,
          marks: 10,
          sol: `#include<stdio.h>\n#include<conio.h>\n#include<stdlib.h>\n\n// Define the structure for a node in the singly linked list\nstruct NODE\n{\n     int data;\n     struct NODE *next;\n};\n\ntypedef struct NODE node;\n\nnode *head = NULL; // Head of the list\n\n// Function to create a new node\nnode *getnode()\n{\n     node *temp = (node *)malloc(sizeof(node));\n     printf(\"Enter the data for the node: \");\n     scanf(\"%d\", &temp->data);\n     temp->next = NULL;\n     return temp;\n}\n\n// Function to create the linked list\nvoid create()\n{\n     int n, i;\n     node *temp, *last;\n\n     printf(\"Enter the number of nodes to be created: \");\n     scanf(\"%d\", &n);\n\n     for (i = 0; i < n; i++)\n     {\n          temp = getnode();\n          if (head == NULL)\n          {\n               head = temp;\n          }\n          else\n          {\n               last->next = temp;\n          }\n          last = temp;\n     }\n}\n\n// Function to display the linked list\nvoid display()\n{\n     node *ptr = head;\n     if (ptr == NULL)\n     {\n          printf(\"The list is empty.\\n\");\n          return;\n     }\n\n     printf(\"Linked List: \");\n     while (ptr != NULL)\n     {\n          printf(\"%d -> \", ptr->data);\n          ptr = ptr->next;\n     }\n     printf(\"NULL\\n\");\n}\n\n// Function to search for a number in the linked list\nvoid search(int value)\n{\n     node *ptr = head;\n     int pos = 1;\n\n     while (ptr != NULL)\n     {\n          if (ptr->data == value)\n          {\n               printf(\"Number %d found at position %d.\\n\", value, pos);\n               return;\n          }\n          ptr = ptr->next;\n          pos++;\n     }\n     printf(\"Number not found.\\n\");\n}\n\n// Main function to drive the program\nvoid main()\n{\n     int num;\n\n     clrscr(); // Clear the screen\n\n     create();  // Create the linked list\n     display(); // Display the linked list\n\n     printf(\"Enter the number to search: \");\n     scanf(\"%d\", &num);\n\n     search(num); // Search for the number in the list\n\n     getch(); // Wait for a key press\n}
`,
        },
      ],
    },
    {
      slipId: 17,
      questions: [
        {
          questionId: 1,
          text: `Write a ‘C’ program to read a postfix expression, evaluate it and display the result.<br> (Use Static Implementation of Stack).`,
          marks: 20,
          sol: `#include<stdio.h>\n#include<conio.h>\n#include<stdlib.h>\n#include<ctype.h>\n\n#define MAX 50 // Maximum size of the stack\n\n// Define the structure for the stack\ntypedef struct\n{\n     int top;\n     int arr[MAX];\n} Stack;\n\n// Function to initialize the stack\nvoid initStack(Stack *s)\n{\n     s->top = -1;\n}\n\n// Function to check if the stack is empty\nint isEmpty(Stack *s)\n{\n     return s->top == -1;\n}\n\n// Function to check if the stack is full\nint isFull(Stack *s)\n{\n     return s->top == MAX - 1;\n}\n\n// Function to push an element onto the stack\nvoid push(Stack *s, int value)\n{\n     if (isFull(s))\n     {\n          printf(\"Stack overflow\\n\");\n          return;\n     }\n     s->arr[++(s->top)] = value;\n}\n\n// Function to pop an element from the stack\nint pop(Stack *s)\n{\n     if (isEmpty(s))\n     {\n          printf(\"Stack underflow\\n\");\n          exit(1);\n     }\n     return s->arr[(s->top)--];\n}\n\n// Function to evaluate postfix expression\nint evaluatePostfix(char *expr)\n{\n     Stack s;\n     initStack(&s);\n     char *p = expr;\n\n     while (*p)\n     {\n          if (isdigit(*p))\n          {\n               push(&s, *p - '0'); // Convert char digit to int\n          }\n          else\n          {\n               int op2 = pop(&s);\n               int op1 = pop(&s);\n               switch (*p)\n               {\n               case '+':\n                    push(&s, op1 + op2);\n                    break;\n               case '-':\n                    push(&s, op1 - op2);\n                    break;\n               case '*':\n                    push(&s, op1 * op2);\n                    break;\n               case '/':\n                    if (op2 != 0)\n                         push(&s, op1 / op2);\n                    else\n                    {\n                         printf(\"Division by zero\\n\");\n                         exit(1);\n                    }\n                    break;\n               default:\n                    printf(\"Invalid operator\\n\");\n                    exit(1);\n               }\n          }\n          p++;\n     }\n     return pop(&s);\n}\n\n// Main function to drive the program\nvoid main()\n{\n     char expr[MAX];\n     int result;\n\n     clrscr(); // Clear the screen\n\n     printf(\"Enter the postfix expression (e.g., 23*54*+): \");\n     gets(expr); // Read postfix expression from user\n\n     result = evaluatePostfix(expr);\n\n     printf(\"The result of the postfix expression is: %d\\n\", result);\n\n     getch(); // Wait for a key press\n}
`,
        },
        {
          questionId: 2,
          text: `Write a ‘C’ program to accept the names of cities and store them in array. Accept the city name from user and use linear search algorithm to check whether the city is present in array or not.`,
          marks: 10,
          sol: `#include<stdio.h>\n#include<conio.h>\n#include<string.h>\n\n#define MAX_CITIES 50\n#define MAX_NAME_LENGTH 50\n\n// Function to perform linear search\nint linearSearch(char cities[][MAX_NAME_LENGTH], int n, char *searchCity)\n{\n     for (int i = 0; i < n; i++)\n     {\n          if (strcmp(cities[i], searchCity) == 0)\n          {\n               return i; // City found at index i\n          }\n     }\n     return -1; // City not found\n}\n\nvoid main()\n{\n     char cities[MAX_CITIES][MAX_NAME_LENGTH]; // Array to store city names\n     char searchCity[MAX_NAME_LENGTH];\n     int n, index;\n\n     clrscr(); // Clear the screen\n\n     // Accept the number of cities\n     printf(\"Enter the number of cities: \");\n     scanf(\"%d\", &n);\n     getch(); // To consume the newline character left by scanf\n\n     // Accept the names of cities\n     for (int i = 0; i < n; i++)\n     {\n          printf(\"Enter city %d: \", i + 1);\n          gets(cities[i]); // Read the city name\n     }\n\n     // Accept the city name to search\n     printf(\"Enter the city name to search: \");\n     gets(searchCity); // Read the city name to search\n\n     // Perform linear search\n     index = linearSearch(cities, n, searchCity);\n\n     // Display the result\n     if (index != -1)\n     {\n          printf(\"City '%s' found at position %d.\\n\", searchCity, index + 1);\n     }\n     else\n     {\n          printf(\"City '%s' not found.\\n\", searchCity);\n     }\n\n     getch(); // Wait for a key press before exiting\n}
`,
        },
      ],
    },
    {
      slipId: 18,
      questions: [
        {
          questionId: 1,
          text: `Write a ‘C’ program to read ‘n’ integers and store them in a binary Search tree structure and count the following and display it:<br> - Number of nodes<br> - Degree of tree<br> - Leaf nodes`,
          marks: 20,
          sol: `#include<stdio.h>\n#include<conio.h>\n#include<stdlib.h>\n\nstruct NODE\n{\n     int data;\n     struct NODE *left, *right;\n};\n\ntypedef struct NODE node;\n\n// Function to create a new node\nnode *createNode(int data)\n{\n     node *newNode = (node *)malloc(sizeof(node));\n     newNode->data = data;\n     newNode->left = newNode->right = NULL;\n     return newNode;\n}\n\n// Function to insert a node into the BST\nnode *insert(node *root, int data)\n{\n     if (root == NULL)\n     {\n          root = createNode(data);\n     }\n     else if (data < root->data)\n     {\n          root->left = insert(root->left, data);\n     }\n     else\n     {\n          root->right = insert(root->right, data);\n     }\n     return root;\n}\n\n// Function to count the number of nodes in the BST\nint countNodes(node *root)\n{\n     if (root == NULL)\n          return 0;\n     return 1 + countNodes(root->left) + countNodes(root->right);\n}\n\n// Function to count the number of leaf nodes in the BST\nint countLeafNodes(node *root)\n{\n     if (root == NULL)\n          return 0;\n     if (root->left == NULL && root->right == NULL)\n          return 1;\n     return countLeafNodes(root->left) + countLeafNodes(root->right);\n}\n\n// Function to find the degree of the tree\nint findDegree(node *root)\n{\n     if (root == NULL)\n          return 0;\n     int leftDegree = findDegree(root->left);\n     int rightDegree = findDegree(root->right);\n     return (root->left ? 1 : 0) + (root->right ? 1 : 0) + leftDegree + rightDegree;\n}\n\n// Main function\nvoid main()\n{\n     node *root = NULL;\n     int n, data;\n\n     clrscr(); // Clear the screen\n\n     // Accept the number of elements\n     printf(\"Enter the number of elements: \");\n     scanf(\"%d\", &n);\n\n     // Accept the elements and insert them into the BST\n     for (int i = 0; i < n; i++)\n     {\n          printf(\"Enter element %d: \", i + 1);\n          scanf(\"%d\", &data);\n          root = insert(root, data);\n     }\n\n     // Count and display results\n     printf(\"\\nNumber of nodes: %d\", countNodes(root));\n     printf(\"\\nDegree of the tree: %d\", findDegree(root));\n     printf(\"\\nNumber of leaf nodes: %d\", countLeafNodes(root));\n\n     getch(); // Wait for a key press before exiting\n}
`,
        },
        {
          questionId: 2,
          text: `Write a ‘C’ program to accept and sort n elements in ascending order using Merge sort method.`,
          marks: 10,
          sol: `#include<stdio.h>\n\n#define MAX 20 // Define a maximum size for the array\n\n// Function to merge two halves of the array\nvoid merge(int a[], int l, int mid, int h)\n{\n     int i = l, j = mid + 1, k = l;\n     int b[MAX]; // Temporary array to store merged result\n\n     // Merge the two halves into the temporary array\n     while (i <= mid && j <= h)\n     {\n          if (a[i] <= a[j])\n          {\n               b[k++] = a[i++];\n          }\n          else\n          {\n               b[k++] = a[j++];\n          }\n     }\n\n     // Copy remaining elements of the left half, if any\n     while (i <= mid)\n     {\n          b[k++] = a[i++];\n     }\n\n     // Copy remaining elements of the right half, if any\n     while (j <= h)\n     {\n          b[k++] = a[j++];\n     }\n\n     // Copy the merged elements back to the original array\n     for (i = l; i <= h; i++)\n     {\n          a[i] = b[i];\n     }\n}\n\n// Function to perform merge sort\nvoid mergeSort(int a[], int l, int h)\n{\n     if (l < h)\n     {\n          int mid = (l + h) / 2;    // Find the middle point\n          mergeSort(a, l, mid);     // Sort the first half\n          mergeSort(a, mid + 1, h); // Sort the second half\n          merge(a, l, mid, h);      // Merge the sorted halves\n     }\n}\n\nint main()\n{\n     int n, a[MAX], i;\n\n     // Get the size of the array from the user\n     printf(\"Enter the size of the array (max %d): \", MAX);\n     scanf(\"%d\", &n);\n\n     if (n > MAX)\n     {\n          printf(\"Size exceeds the maximum limit of %d\\n\", MAX);\n          return 1; // Exit with error code\n     }\n\n     // Input array elements\n     for (i = 0; i < n; i++)\n     {\n          printf(\"Enter element %d: \", i + 1);\n          scanf(\"%d\", &a[i]);\n     }\n\n     // Display original array\n     printf(\"Original Array:\\n\");\n     for (i = 0; i < n; i++)\n     {\n          printf(\"%d\\t\", a[i]);\n     }\n     printf(\"\\n\");\n\n     // Sort the array using merge sort\n     mergeSort(a, 0, n - 1);\n\n     // Display sorted array\n     printf(\"Sorted Array:\\n\");\n     for (i = 0; i < n; i++)\n     {\n          printf(\"%d\\t\", a[i]);\n     }\n     printf(\"\\n\");\n\n     return 0;\n}
`,
        },
      ],
    },
    {
      slipId: 19,
      questions: [
        {
          questionId: 1,
          text: `Write a ‘C’ program which accept the string and reverse each word of the string using Dynamic implementation of stack.<br> Example: Input - This is an input string<br> Output - sihTsi na tupnignirts`,
          marks: 20,
          sol: `#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n\n#define MAX 100 // Define maximum size for the stack and string\n\n// Define a stack structure to hold words\ntypedef struct\n{\n     char *arr[MAX]; // Array to hold pointers to words\n     int top;        // Index of the top element\n} Stack;\n\n// Function to create a stack\nvoid createStack(Stack *stack)\n{\n     stack->top = -1; // Initialize the top of the stack to -1 (empty)\n}\n\n// Function to push a word onto the stack\nvoid push(Stack *stack, char *word)\n{\n     if (stack->top < MAX - 1)\n     {\n          stack->arr[++stack->top] = word; // Increment top and add word to stack\n     }\n}\n\n// Function to pop a word from the stack\nchar *pop(Stack *stack)\n{\n     if (stack->top >= 0)\n     {\n          return stack->arr[stack->top--]; // Return the top word and decrement top\n     }\n     return NULL; // Return NULL if stack is empty\n}\n\n// Function to reverse a word\nvoid reverseWord(char *word)\n{\n     int start = 0;\n     int end = strlen(word) - 1;\n     while (start < end)\n     {\n          // Swap characters at start and end\n          char temp = word[start];\n          word[start] = word[end];\n          word[end] = temp;\n          start++;\n          end--;\n     }\n}\n\n// Function to reverse each word in a string\nvoid reverseWords(char *str)\n{\n     Stack stack;\n     createStack(&stack);\n\n     char *token = strtok(str, \" \"); // Split the string into words by spaces\n\n     while (token != NULL)\n     {\n          char *word = (char *)malloc(strlen(token) + 1); // Allocate memory for the word\n          strcpy(word, token);                            // Copy the token into the new word\n          reverseWord(word);                              // Reverse the word\n          push(&stack, word);                             // Push the reversed word onto the stack\n          token = strtok(NULL, \" \");                      // Move to the next word\n     }\n\n     // Pop words from the stack and print them\n     while (stack.top != -1)\n     {\n          printf(\"%s \", pop(&stack));\n     }\n     printf(\"\\n\");\n\n     // Free allocated memory\n     for (int i = 0; i <= stack.top; i++)\n     {\n          free(stack.arr[i]);\n     }\n}\n\nint main()\n{\n     char str[MAX];\n\n     // Get the input string from the user\n     printf(\"Enter a string: \");\n     fgets(str, sizeof(str), stdin);\n     str[strcspn(str, \"\\n\")] = '\\0'; // Remove trailing newline\n\n     // Reverse each word in the string\n     printf(\"Reversed string with each word reversed: \");\n     reverseWords(str);\n\n     return 0;\n}
`,
        },
        {
          questionId: 2,
          text: `Write a ‘C’ program to create a singly Link list and display its alternative nodes.<br> (start displaying from first node)`,
          marks: 10,
          sol: `#include<stdio.h>\n#include<conio.h>\n#include<stdlib.h>\n\nstruct NODE\n{\n     int data;\n     struct NODE *next;\n};\ntypedef struct NODE node;\n\nnode *list = NULL, *last;\n\n// Create a new node with user input\nnode *getnode()\n{\n     node *temp;\n     temp = (node *)malloc(sizeof(node));\n     printf(\"\\nEnter the data: \");\n     scanf(\"%d\", &temp->data);\n     temp->next = NULL;\n     return temp;\n}\n\n// Create a linked list with 'n' nodes\nvoid create()\n{\n     int n, i;\n     node *temp;\n\n     printf(\"\\nEnter total nodes to be created: \");\n     scanf(\"%d\", &n);\n     for (i = 0; i < n; i++)\n     {\n          temp = getnode();\n          if (list == NULL)\n               list = temp;\n          else\n               last->next = temp;\n          last = temp;\n     }\n}\n\n// Display the entire linked list\nvoid display()\n{\n     node *ptr;\n     for (ptr = list; ptr != NULL; ptr = ptr->next)\n          printf(\"%d->\", ptr->data);\n     printf(\"NULL\");\n}\n\n// Display alternate nodes in the linked list\nvoid displayalternate()\n{\n     node *ptr;\n     int cnt;\n     for (ptr = list, cnt = 1; ptr != NULL; ptr = ptr->next, cnt++)\n     {\n          if (cnt % 2 != 0)\n               printf(\"%d->\", ptr->data);\n     }\n     printf(\"NULL\");\n}\n\nvoid main()\n{\n     clrscr(); // Clear screen\n     create();\n     display();\n     printf(\"\\nAlternate nodes in LL: \");\n     displayalternate();\n     getch(); // Wait for user input\n}
`,
        },
      ],
    },
    {
      slipId: 20,
      questions: [
        {
          questionId: 1,
          text: `Write a ‘C’ program which accept the string and check whether the string is Palindrome or not using stack.<br> (Use Static/Dynamic implementation of Stack)`,
          marks: 20,
          sol: `#include<stdio.h>\n#include<conio.h>\n#include<string.h> // Include for strcmp function\n#define MAX 50\n\nstruct STACK\n{\n     char stk[MAX];\n     int top;\n};\ntypedef struct STACK stack;\n\n// Initialize the stack\nvoid initstack(stack *s)\n{\n     s->top = -1;\n}\n\n// Check if the stack is empty\nint isempty(stack *s)\n{\n     return (s->top == -1);\n}\n\n// Check if the stack is full\nint isfull(stack *s)\n{\n     return (s->top == MAX - 1);\n}\n\n// Push an element onto the stack\nvoid push(stack *s, char data)\n{\n     s->stk[++s->top] = data;\n}\n\n// Pop an element from the stack\nchar pop(stack *s)\n{\n     return s->stk[s->top--];\n}\n\nvoid main()\n{\n     stack s;\n     char string[50], revstr[50];\n     int i, j = 0;\n\n     clrscr(); // Clear screen\n     initstack(&s);\n     printf(\"\\nEnter the String: \");\n     gets(string); // Read the string\n\n     // Push each character onto the stack\n     for (i = 0; string[i] != '\\0'; i++)\n     {\n          if (isfull(&s))\n               printf(\"\\nStack is FULL.\");\n          else\n               push(&s, string[i]);\n     }\n\n     // Pop each character to form the reversed string\n     while (!isempty(&s))\n          revstr[j++] = pop(&s);\n     revstr[j] = '\\0'; // Null-terminate the reversed string\n\n     // Check if the original and reversed strings are the same\n     if (strcmp(string, revstr) == 0)\n          printf(\"\\nString is Palindrome.\");\n     else\n          printf(\"\\nString is not Palindrome.\");\n\n     getch(); // Wait for user input\n}
`,
        },
        {
          questionId: 2,
          text: `Write a ‘C’ program to swap mth and nth element of singly linked list.`,
          marks: 10,
          sol: `#include<stdio.h>\n#include<conio.h>\n\nstruct NODE\n{\n     int data;\n     struct NODE *next;\n};\ntypedef struct NODE node;\n\nnode *list = NULL, *last;\n\n// Create a new node\nnode *getnode()\n{\n     node *temp;\n     temp = (node *)malloc(sizeof(node));\n     printf(\"\\nEnter the data: \");\n     scanf(\"%d\", &temp->data);\n     temp->next = NULL;\n     return temp;\n}\n\n// Create a linked list with n nodes\nvoid create()\n{\n     int n, i;\n     node *temp;\n\n     printf(\"\\nEnter total nodes to be created: \");\n     scanf(\"%d\", &n);\n     for (i = 0; i < n; i++)\n     {\n          temp = getnode();\n          if (list == NULL)\n               list = temp;\n          else\n               last->next = temp;\n          last = temp;\n     }\n}\n\n// Display the linked list\nvoid display()\n{\n     node *ptr;\n     for (ptr = list; ptr != NULL; ptr = ptr->next)\n          printf(\"\\t%d\", ptr->data);\n}\n\n// Swap data between two nodes at specified positions\nvoid swap()\n{\n     node *ptr, *ptr1;\n     int pos, m, n, temp;\n     printf(\"\\nEnter the position of mth and nth to be swapped: \");\n     scanf(\"%d%d\", &m, &n);\n\n     // Locate the mth node\n     for (ptr = list, pos = 1; ptr != NULL && pos < m; ptr = ptr->next, pos++)\n          ;\n     // Locate the nth node\n     for (ptr1 = list, pos = 1; ptr1 != NULL && pos < n; ptr1 = ptr1->next, pos++)\n          ;\n\n     if (ptr != NULL && ptr1 != NULL)\n     {\n          // Swap data between mth and nth nodes\n          temp = ptr->data;\n          ptr->data = ptr1->data;\n          ptr1->data = temp;\n     }\n     else\n          printf(\"\\nPosition is invalid\");\n}\n\nvoid main()\n{\n     clrscr();  // Clear screen\n     create();  // Create the linked list\n     display(); // Display the original list\n     swap();    // Swap nodes\n     printf(\"\\nLinked list after Swapping: \");\n     display(); // Display the list after swapping\n     getch();   // Wait for user input\n}
`,
        },
      ],
    },
    {
      slipId: 21,
      questions: [
        {
          questionId: 1,
          text: `Write a ‘C’ program to read an adjacency matrix of a directed graph and traverse using BFS.`,
          marks: 20,
          so0l: `#include<stdio.h>\n#include<conio.h>\n\n#define MAX 10 // Maximum number of vertices in the graph\n\n// Function to perform BFS traversal\nvoid bfs(int graph[MAX][MAX], int visited[MAX], int n, int start)\n{\n     int queue[MAX], front = 0, rear = 0;\n     int i;\n\n     // Mark the start node as visited and enqueue it\n     visited[start] = 1;\n     queue[rear++] = start;\n\n     printf(\"BFS Traversal starting from node %d:\\n\", start);\n\n     while (front < rear)\n     {\n          int node = queue[front++]; // Dequeue a node\n\n          printf(\"%d \", node);\n\n          // Process all adjacent nodes\n          for (i = 0; i < n; i++)\n          {\n               if (graph[node][i] && !visited[i])\n               {\n                    visited[i] = 1;    // Mark as visited\n                    queue[rear++] = i; // Enqueue the node\n               }\n          }\n     }\n     printf(\"\\n\");\n}\n\nint main()\n{\n     int graph[MAX][MAX], visited[MAX], n, i, j, start;\n\n     clrscr(); // Clear the screen (Turbo C specific)\n\n     // Initialize visited array to 0\n     for (i = 0; i < MAX; i++)\n     {\n          visited[i] = 0;\n     }\n\n     // Read the number of vertices\n     printf(\"Enter the number of vertices (max %d): \", MAX);\n     scanf(\"%d\", &n);\n\n     // Read the adjacency matrix\n     printf(\"Enter the adjacency matrix:\\n\");\n     for (i = 0; i < n; i++)\n     {\n          for (j = 0; j < n; j++)\n          {\n               scanf(\"%d\", &graph[i][j]);\n          }\n     }\n\n     // Read the starting node for BFS\n     printf(\"Enter the starting node for BFS: \");\n     scanf(\"%d\", &start);\n\n     // Perform BFS traversal\n     bfs(graph, visited, n, start);\n\n     getch(); // Wait for user input before closing (Turbo C specific)\n     return 0;\n}
`,
        },
        {
          questionId: 2,
          text: `Write a ‘C’ program Accept n elements from user store it in an array. Accept a value from the user and use linear/Sequential search method to check whether the value is present in array or not. Display proper message.`,
          marks: 10,
          sol: `#include<stdio.h>\n#include<conio.h> // For Turbo C's clrscr() and getch()\n\n// Function to perform linear search\nint linearSearch(int arr[], int n, int value)\n{\n     int i;\n     for (i = 0; i < n; i++)\n     {\n          if (arr[i] == value)\n          {\n               return i; // Return index if value is found\n          }\n     }\n     return -1; // Return -1 if value is not found\n}\n\nint main()\n{\n     int n, i, value, result;\n     int arr[100]; // Array to store elements\n\n     clrscr(); // Clear the screen (Turbo C specific)\n\n     // Read the number of elements\n     printf(\"Enter the number of elements (max 100): \");\n     scanf(\"%d\", &n);\n\n     // Check if the number of elements is within the allowed range\n     if (n > 100 || n <= 0)\n     {\n          printf(\"Invalid number of elements.\\n\");\n          getch();  // Wait for user input before closing (Turbo C specific)\n          return 1; // Exit the program with an error code\n     }\n\n     // Read the elements of the array\n     printf(\"Enter %d elements:\\n\", n);\n     for (i = 0; i < n; i++)\n     {\n          printf(\"Element %d: \", i + 1);\n          scanf(\"%d\", &arr[i]);\n     }\n\n     // Read the value to search for\n     printf(\"Enter the value to search for: \");\n     scanf(\"%d\", &value);\n\n     // Perform linear search\n     result = linearSearch(arr, n, value);\n\n     // Display the result\n     if (result != -1)\n     {\n          printf(\"Value %d found at index %d.\\n\", value, result);\n     }\n     else\n     {\n          printf(\"Value %d not found in the array.\\n\", value);\n     }\n\n     getch(); // Wait for user input before closing (Turbo C specific)\n     return 0;\n}
`,
        },
      ],
    },
    {
      slipId: 22,
      questions: [
        {
          questionId: 1,
          text: `Write a ‘C’ program which accept an Expression and check whether the expression is Parenthesized or not using stack.<br> (Use Static/Dynamic implementation of Stack)`,
          marks: 20,
          sol: `#include<stdio.h>\n#include<conio.h> // For Turbo C's clrscr() and getch()\n\n#define MAX 100 // Maximum size of the stack\n\n// Stack structure\ntypedef struct\n{\n     int top;\n     char items[MAX];\n} Stack;\n\n// Function to initialize the stack\nvoid initStack(Stack *s)\n{\n     s->top = -1;\n}\n\n// Function to push an element onto the stack\nvoid push(Stack *s, char item)\n{\n     if (s->top == MAX - 1)\n     {\n          printf(\"Stack overflow\\n\");\n     }\n     else\n     {\n          s->items[++(s->top)] = item;\n     }\n}\n\n// Function to pop an element from the stack\nchar pop(Stack *s)\n{\n     if (s->top == -1)\n     {\n          return '\\0'; // Return a null character if stack is empty\n     }\n     else\n     {\n          return s->items[(s->top)--];\n     }\n}\n\n// Function to check if the stack is empty\nint isEmpty(Stack *s)\n{\n     return s->top == -1;\n}\n\n// Function to check if the given expression is parenthesized correctly\nint isParenthesized(char *expr)\n{\n     Stack s;\n     initStack(&s);\n\n     char ch;\n     while ((ch = *expr++) != '\\0')\n     {\n          if (ch == '(' || ch == '{' || ch == '[')\n          {\n               push(&s, ch);\n          }\n          else if (ch == ')' || ch == '}' || ch == ']')\n          {\n               if (isEmpty(&s))\n               {\n                    return 0; // Stack is empty, but closing parenthesis found\n               }\n               char open = pop(&s);\n               if ((ch == ')' && open != '(') ||\n                   (ch == '}' && open != '{') ||\n                   (ch == ']' && open != '['))\n               {\n                    return 0; // Mismatched parentheses\n               }\n          }\n     }\n\n     return isEmpty(&s); // If stack is empty, all parentheses are matched\n}\n\nint main()\n{\n     char expr[MAX];\n\n     clrscr(); // Clear the screen (Turbo C specific)\n\n     // Read the expression from the user\n     printf(\"Enter the expression: \");\n     gets(expr); // Use gets() to read the entire line of input\n\n     // Check if the expression is parenthesized correctly\n     if (isParenthesized(expr))\n     {\n          printf(\"The expression is correctly parenthesized.\\n\");\n     }\n     else\n     {\n          printf(\"The expression is not correctly parenthesized.\\n\");\n     }\n\n     getch(); // Wait for user input before closing (Turbo C specific)\n     return 0;\n}
`,
        },
        {
          questionId: 2,
          text: `Write a ‘C’ program to count all non-zero elements, odd numbers and even numbers in the singly linked list.`,
          marks: 10,
          sol: `#include<stdio.h>\n#include<conio.h>\n\n// Define the NODE structure\nstruct NODE\n{\n     int data;\n     struct NODE *next;\n};\ntypedef struct NODE node;\nnode *list = NULL, *last;\n\n// Create a new node with input data\nnode *getnode()\n{\n     node *temp;\n     temp = (node *)malloc(sizeof(node));\n     printf(\"\\nEnter the data: \");\n     scanf(\"%d\", &temp->data);\n     temp->next = NULL;\n     return temp;\n}\n\n// Create a linked list with n nodes\nvoid create()\n{\n     int n, i;\n     node *temp;\n\n     printf(\"\\nEnter total nodes to be created: \");\n     scanf(\"%d\", &n);\n     for (i = 0; i < n; i++)\n     {\n          temp = getnode();\n          if (list == NULL)\n               list = temp;\n          else\n               last->next = temp;\n          last = temp;\n     }\n}\n\n// Display the linked list\nvoid display()\n{\n     node *ptr;\n     for (ptr = list; ptr != NULL; ptr = ptr->next)\n          printf(\"\\t%d\", ptr->data);\n}\n\n// Count non-zero, even, and odd numbers in the list\nvoid count()\n{\n     int nonzero = 0, even = 0, odd = 0;\n     node *ptr;\n     for (ptr = list; ptr != NULL; ptr = ptr->next)\n     {\n          if (ptr->data != 0)\n               nonzero++;\n          if (ptr->data % 2 == 0)\n               even++;\n          else\n               odd++;\n     }\n     printf(\"\\nTotal non-zero Numbers = %d\", nonzero);\n     printf(\"\\nTotal even Numbers = %d\", even);\n     printf(\"\\nTotal odd Numbers = %d\", odd);\n}\n\nvoid main()\n{\n     int ch, val;\n     clrscr();\n     create();  // Create the linked list\n     display(); // Display the linked list\n     count();   // Count and display non-zero, even, and odd numbers\n     getch();   // Wait for user input\n}
`,
        },
      ],
    },
    {
      slipId: 23,
      questions: [
        {
          questionId: 1,
          text: `Write a menu driven program using ‘C’ for singly linked list:<br> - To create linked list.<br> - To display linked list<br> - To insert node at last position of linked list.<br> - To delete node from specific position of linked list.`,
          marks: 20,
          sol: `#include<stdio.h>\n#include<conio.h>\n\n// Define the NODE structure\nstruct NODE\n{\n     int data;\n     struct NODE *next;\n};\ntypedef struct NODE node;\n\nnode *list = NULL, *last;\n\n// Create a new node with input data\nnode *getnode()\n{\n     node *temp;\n     temp = (node *)malloc(sizeof(node));\n     printf(\"\\nEnter the data: \");\n     scanf(\"%d\", &temp->data);\n     temp->next = NULL;\n     return temp;\n}\n\n// Create a linked list with n nodes\nvoid create()\n{\n     int n, i;\n     node *temp;\n\n     printf(\"\\nEnter total nodes to be created: \");\n     scanf(\"%d\", &n);\n     for (i = 0; i < n; i++)\n     {\n          temp = getnode();\n          if (list == NULL)\n               list = temp;\n          else\n               last->next = temp;\n          last = temp;\n     }\n}\n\n// Display the linked list\nvoid display()\n{\n     node *ptr;\n     for (ptr = list; ptr != NULL; ptr = ptr->next)\n          printf(\"\\t%d\", ptr->data);\n}\n\n// Search for a value in the linked list\nvoid search(int val)\n{\n     node *ptr;\n     int pos;\n\n     for (ptr = list, pos = 1; ptr != NULL && ptr->data != val; ptr = ptr->next, pos++)\n          ;\n     if (ptr != NULL && ptr->data == val)\n          printf(\"Value is found in LL at position %d.\", pos);\n     else\n          printf(\"Value not found.\");\n}\n\n// Insert a new node at the end of the linked list\nvoid insertend()\n{\n     node *temp;\n     temp = getnode();\n     last->next = temp;\n     last = temp;\n}\n\n// Delete a node at a specific position\nnode *deletepos()\n{\n     int pos, i;\n     node *ptr, *prev;\n     printf(\"\\nEnter the position for deleting node: \");\n     scanf(\"%d\", &pos);\n\n     if (pos == 1)\n     {\n          ptr = list;\n          list = ptr->next;\n          free(ptr);\n     }\n     else\n     {\n          for (ptr = list, prev = list, i = 1; ptr != NULL && i < pos; prev = ptr, ptr = ptr->next, i++)\n               ;\n          if (ptr != NULL)\n          {\n               prev->next = ptr->next;\n               free(ptr);\n          }\n          else\n               printf(\"\\nPosition not found.\");\n     }\n     return list;\n}\n\nvoid main()\n{\n     int ch, val;\n     clrscr();\n\n     while (1)\n     {\n          printf(\"\\n1: Create the Linked List.\");\n          printf(\"\\n2: Display the Linked List.\");\n          printf(\"\\n3: Insert at Last Position.\");\n          printf(\"\\n4: Delete by Position\");\n          printf(\"\\n5: Exit.\");\n          printf(\"\\nEnter your choice: \");\n          scanf(\"%d\", &ch);\n          switch (ch)\n          {\n          case 1:\n               create();\n               break;\n          case 2:\n               display();\n               break;\n          case 3:\n               insertend();\n               break;\n          case 4:\n               list = deletepos();\n               break;\n          case 5:\n               exit(0);\n               break;\n          }\n     }\n     getch();\n}
`,
        },
        {
          questionId: 2,
          text: `Write a ‘C’ program to create a random array of n integers. Accept a value x from user and use Binary search algorithm to check whether the number is present in array or not.<br> (Students can accept sorted array or can use any sorting method to sort the array)`,
          marks: 10,
          sol: `#include<stdio.h>\n#include<stdlib.h>\n#include<time.h>\n\n#define MAX 100\n\n// Function to sort the array using Bubble Sort\nvoid bubbleSort(int arr[], int n)\n{\n     int i, j, temp;\n     for (i = 0; i < n - 1; i++)\n     {\n          for (j = 0; j < n - i - 1; j++)\n          {\n               if (arr[j] > arr[j + 1])\n               {\n                    // Swap arr[j] and arr[j + 1]\n                    temp = arr[j];\n                    arr[j] = arr[j + 1];\n                    arr[j + 1] = temp;\n               }\n          }\n     }\n}\n\n// Function to perform binary search\nint binarySearch(int arr[], int n, int x)\n{\n     int low = 0, high = n - 1, mid;\n     while (low <= high)\n     {\n          mid = (low + high) / 2;\n          if (arr[mid] == x)\n          {\n               return mid; // Element found\n          }\n          else if (arr[mid] < x)\n          {\n               low = mid + 1;\n          }\n          else\n          {\n               high = mid - 1;\n          }\n     }\n     return -1; // Element not found\n}\n\n// Main function\nint main()\n{\n     int n, arr[MAX], i, x, index;\n\n     // Seed the random number generator\n     srand(time(0));\n\n     // Accept the size of the array\n     printf(\"Enter the number of elements in the array: \");\n     scanf(\"%d\", &n);\n\n     // Generate random numbers and store them in the array\n     printf(\"Generated array:\\n\");\n     for (i = 0; i < n; i++)\n     {\n          arr[i] = rand() % 100; // Generate random numbers between 0 and 99\n          printf(\"%d\\t\", arr[i]);\n     }\n     printf(\"\\n\");\n\n     // Sort the array using Bubble Sort\n     bubbleSort(arr, n);\n\n     // Display the sorted array\n     printf(\"Sorted array:\\n\");\n     for (i = 0; i < n; i++)\n     {\n          printf(\"%d\\t\", arr[i]);\n     }\n     printf(\"\\n\");\n\n     // Accept the value to search for\n     printf(\"Enter the value to search for: \");\n     scanf(\"%d\", &x);\n\n     // Perform binary search\n     index = binarySearch(arr, n, x);\n\n     // Display the result\n     if (index != -1)\n     {\n          printf(\"Value %d found at index %d.\\n\", x, index);\n     }\n     else\n     {\n          printf(\"Value %d not found in the array.\\n\", x);\n     }\n\n     return 0;\n}
`,
        },
      ],
    },
    {
      slipId: 24,
      questions: [
        {
          questionId: 1,
          text: `Write a ‘C’ program to read a postfix expression, evaluate it and display the result.<br> (Use Dynamic Implementation of Stack)`,
          marks: 20,
          sol: `#include<stdio.h>\n#include<conio.h>\n#include<math.h> // Required for pow function\n\n#define MAX 30\n\nstruct STACK\n{\n     double stk[MAX];\n     int top;\n};\ntypedef struct STACK stack;\n\n// Initialize the stack\nvoid initstack(stack *s)\n{\n     for (int i = 0; i < MAX; i++)\n          s->stk[i] = 0;\n     s->top = -1;\n}\n\n// Check if the stack is empty\nint isempty(stack *s)\n{\n     return s->top == -1;\n}\n\n// Check if the stack is full\nint isfull(stack *s)\n{\n     return s->top == MAX - 1;\n}\n\n// Push a value onto the stack\nvoid push(stack *s, double data)\n{\n     s->stk[++s->top] = data;\n}\n\n// Pop a value from the stack\ndouble pop(stack *s)\n{\n     return s->stk[s->top--];\n}\n\n// Display the stack contents\nvoid display(stack *s)\n{\n     printf(\"\\nStack: \");\n     for (int i = 0; i <= s->top; i++)\n          printf(\"\\t%f\", s->stk[i]);\n}\n\n// Check if a character is a digit\nint isdigit(char symb)\n{\n     return symb >= '0' && symb <= '9';\n}\n\n// Perform arithmetic operations\ndouble eval(double opnd1, double opnd2, char symb)\n{\n     switch (symb)\n     {\n     case '+':\n          return opnd1 + opnd2;\n     case '-':\n          return opnd1 - opnd2;\n     case '*':\n          return opnd1 * opnd2;\n     case '/':\n          return opnd1 / opnd2;\n     case '^':\n          return pow(opnd1, opnd2);\n     }\n     return 0;\n}\n\n// Evaluate postfix expression\ndouble posteval(char *expr)\n{\n     stack s;\n     initstack(&s);\n\n     for (int i = 0; expr[i] != '\\0'; i++)\n     {\n          if (isdigit(expr[i]))\n               push(&s, expr[i] - 48);\n          else\n          {\n               double opnd2 = pop(&s);\n               double opnd1 = pop(&s);\n               push(&s, eval(opnd1, opnd2, expr[i]));\n          }\n     }\n\n     display(&s);\n     return pop(&s);\n}\n\nvoid main()\n{\n     char expr[MAX];\n     clrscr(); // Clear screen (specific to some compilers)\n     printf(\"\\nEnter the Expression: \");\n     scanf(\" %s\", expr);\n\n     printf(\"Result after postfix Evaluation = %f\", posteval(expr));\n     getch(); // Wait for user input (specific to some compilers)\n}
`,
        },
        {
          questionId: 2,
          text: `Write a ‘C’ program to remove last node of the singly linked list and insert it at the beginning of list.`,
          marks: 10,
          sol: `#include<stdio.h>\n#include<conio.h>\n\nstruct NODE\n{\n     int data;\n     struct NODE *next;\n};\ntypedef struct NODE node;\n\nnode *list = NULL, *last;\n\n// Create a new node with input data\nnode *getnode()\n{\n     node *temp;\n     temp = (node *)malloc(sizeof(node));\n     printf(\"\\nEnter the data: \");\n     scanf(\"%d\", &temp->data);\n     temp->next = NULL;\n     return temp;\n}\n\n// Create a linked list with n nodes\nvoid create()\n{\n     int n, i;\n     node *temp;\n\n     printf(\"\\nEnter total nodes to be created: \");\n     scanf(\"%d\", &n);\n     for (i = 0; i < n; i++)\n     {\n          temp = getnode();\n          if (list == NULL)\n               list = temp;\n          else\n               last->next = temp;\n          last = temp;\n     }\n}\n\n// Display the linked list\nvoid display()\n{\n     node *ptr;\n     for (ptr = list; ptr != NULL; ptr = ptr->next)\n          printf(\"%d->\", ptr->data);\n     printf(\"NULL\");\n}\n\n// Remove the last node and add it at the beginning of the list\nnode *removelastaddfirst()\n{\n     node *ptr, *prev;\n\n     // Traverse to the last node\n     for (ptr = list, prev = list; ptr->next != NULL; prev = ptr, ptr = ptr->next)\n          ;\n\n     // Remove last node\n     prev->next = NULL;\n\n     // Add removed node at the beginning\n     ptr->next = list;\n     list = ptr;\n\n     return list;\n}\n\nvoid main()\n{\n     int ch, val;\n     clrscr();\n\n     // Create and display the initial list\n     create();\n     display();\n\n     // Remove last node and add it at the beginning\n     list = removelastaddfirst();\n     printf(\"\\nList after removing last node and adding at first: \");\n     display();\n\n     getch();\n}
`,
        },
      ],
    },
    {
      slipId: 25,
      questions: [
        {
          questionId: 1,
          text: `Write a ‘C’ program to read an adjacency matrix of a directed graph and traverse it using DFS.`,
          marks: 20,
          sol: `#include<stdio.h>\n#include<conio.h>\n#include<malloc.h>\n\n#define MAX 50\n\nint adjMatrix[MAX][MAX]; // Adjacency matrix\nint visited[MAX];        // Array to keep track of visited nodes\nint n;                   // Number of vertices\n\n// Function to perform DFS traversal\nvoid dfs(int v)\n{\n     int i;\n     // Mark the current node as visited\n     visited[v] = 1;\n     printf(\"%d \", v);\n\n     // Traverse all adjacent vertices\n     for (i = 0; i < n; i++)\n     {\n          if (adjMatrix[v][i] && !visited[i])\n          {\n               dfs(i);\n          }\n     }\n}\n\nvoid main()\n{\n     int i, j, startVertex;\n\n     clrscr(); // Clear the screen\n\n     // Read the number of vertices\n     printf(\"Enter the number of vertices: \");\n     scanf(\"%d\", &n);\n\n     // Initialize the adjacency matrix\n     printf(\"Enter the adjacency matrix (0s and 1s):\\n\");\n     for (i = 0; i < n; i++)\n     {\n          for (j = 0; j < n; j++)\n          {\n               scanf(\"%d\", &adjMatrix[i][j]);\n          }\n     }\n\n     // Initialize visited array to 0\n     for (i = 0; i < n; i++)\n     {\n          visited[i] = 0;\n     }\n\n     // Read the starting vertex for DFS\n     printf(\"Enter the starting vertex for DFS: \");\n     scanf(\"%d\", &startVertex);\n\n     // Perform DFS traversal\n     printf(\"DFS Traversal starting from vertex %d:\\n\", startVertex);\n     dfs(startVertex);\n\n     getch(); // Wait for a key press\n}
`,
        },
        {
          questionId: 2,
          text: `Write a menu driven program using ‘C’ for singly linked list:<br> - To create linked list.<br> - To display linked list`,
          marks: 10,
          sol: `#include<stdio.h>\n#include<conio.h>\n#include<malloc.h>\n\nstruct NODE\n{\n     int data;\n     struct NODE *next;\n};\ntypedef struct NODE node;\n\nnode *list = NULL, *last = NULL;\n\n// Create a new node with input data\nnode *getnode()\n{\n     node *temp;\n     temp = (node *)malloc(sizeof(node));\n     printf(\"\\nEnter the data: \");\n     scanf(\"%d\", &temp->data);\n     temp->next = NULL;\n     return temp;\n}\n\n// Create a linked list with user-specified number of nodes\nvoid create()\n{\n     int n, i;\n     node *temp;\n\n     printf(\"\\nEnter the number of nodes to be created: \");\n     scanf(\"%d\", &n);\n     for (i = 0; i < n; i++)\n     {\n          temp = getnode();\n          if (list == NULL)\n          {\n               list = temp;\n               last = temp;\n          }\n          else\n          {\n               last->next = temp;\n               last = temp;\n          }\n     }\n}\n\n// Display the linked list\nvoid display()\n{\n     node *ptr;\n     if (list == NULL)\n     {\n          printf(\"\\nThe list is empty.\");\n          return;\n     }\n     printf(\"\\nLinked List: \");\n     for (ptr = list; ptr != NULL; ptr = ptr->next)\n     {\n          printf(\"%d -> \", ptr->data);\n     }\n     printf(\"NULL\");\n}\n\n// Main menu-driven function\nvoid main()\n{\n     int choice;\n\n     clrscr(); // Clear the screen\n\n     while (1)\n     {\n          printf(\"\\n\\nMenu:\");\n          printf(\"\\n1. Create Linked List\");\n          printf(\"\\n2. Display Linked List\");\n          printf(\"\\n3. Exit\");\n          printf(\"\\nEnter your choice: \");\n          scanf(\"%d\", &choice);\n\n          switch (choice)\n          {\n          case 1:\n               create();\n               break;\n          case 2:\n               display();\n               break;\n          case 3:\n               exit(0);\n          default:\n               printf(\"\\nInvalid choice. Please try again.\");\n          }\n     }\n\n     getch(); // Wait for a key press\n}
`,
        },
      ],
    },
    {
      slipId: 26,
      questions: [
        {
          questionId: 1,
          text: `Write a ‘C’ program to accept an infix expression, convert it into its equivalent prefix expression and display the result.<br> (Use Static Implementation of Stack)`,
          marks: 20,
          sol: `#include<stdio.h>\n#include<string.h>\n#include<ctype.h>\n\n#define MAX 100\n\n// Stack data structure\ntypedef struct\n{\n     int top;\n     char items[MAX];\n} Stack;\n\nvoid push(Stack *s, char item)\n{\n     if (s->top < MAX - 1)\n     {\n          s->items[++(s->top)] = item;\n     }\n}\n\nchar pop(Stack *s)\n{\n     if (s->top >= 0)\n     {\n          return s->items[(s->top)--];\n     }\n     return '\\0';\n}\n\nchar peek(Stack *s)\n{\n     if (s->top >= 0)\n     {\n          return s->items[s->top];\n     }\n     return '\\0';\n}\n\nint isEmpty(Stack *s)\n{\n     return s->top == -1;\n}\n\nint precedence(char op)\n{\n     switch (op)\n     {\n     case '+':\n     case '-':\n          return 1;\n     case '*':\n     case '/':\n          return 2;\n     case '^':\n          return 3;\n     default:\n          return 0;\n     }\n}\n\nvoid infixToPrefix(char *infix, char *prefix)\n{\n     Stack s;\n     s.top = -1;\n     int length = strlen(infix);\n     int i, k = 0;\n\n     // Reverse infix expression\n     char rev_infix[MAX];\n     for (i = length - 1; i >= 0; i--)\n     {\n          rev_infix[length - 1 - i] = infix[i];\n     }\n     rev_infix[length] = '\\0';\n\n     // Convert reversed infix to postfix\n     char postfix[MAX];\n     for (i = 0; rev_infix[i] != '\\0'; i++)\n     {\n          if (isalnum(rev_infix[i]))\n          {\n               postfix[k++] = rev_infix[i];\n          }\n          else if (rev_infix[i] == '(')\n          {\n               push(&s, ')');\n          }\n          else if (rev_infix[i] == ')')\n          {\n               while (!isEmpty(&s) && peek(&s) != ')')\n               {\n                    postfix[k++] = pop(&s);\n               }\n               pop(&s);\n          }\n          else\n          {\n               while (!isEmpty(&s) && precedence(rev_infix[i]) <= precedence(peek(&s)))\n               {\n                    postfix[k++] = pop(&s);\n               }\n               push(&s, rev_infix[i]);\n          }\n     }\n     while (!isEmpty(&s))\n     {\n          postfix[k++] = pop(&s);\n     }\n     postfix[k] = '\\0';\n\n     // Reverse postfix to get prefix\n     for (i = strlen(postfix) - 1; i >= 0; i--)\n     {\n          prefix[strlen(postfix) - 1 - i] = postfix[i];\n     }\n     prefix[strlen(postfix)] = '\\0';\n}\n\nint main()\n{\n     char infix[MAX], prefix[MAX];\n\n     clrscr(); // Clear the screen (Turbo C specific)\n\n     printf(\"Enter infix expression: \");\n     gets(infix); // Read the infix expression\n\n     infixToPrefix(infix, prefix);\n\n     printf(\"Prefix expression: %s\\n\", prefix);\n\n     getch(); // Wait for user input before closing (Turbo C specific)\n     return 0;\n}
`,
        },
        {
          questionId: 2,
          text: `Write a ‘C’ program to create two singly linked lists and concatenate one list at the end of another list.`,
          marks: 10,
          sol: `#include<stdio.h>\n#include<stdlib.h>\n\ntypedef struct Node\n{\n     int data;\n     struct Node *next;\n} Node;\n\nNode *createNode(int data)\n{\n     Node *newNode = (Node *)malloc(sizeof(Node));\n     newNode->data = data;\n     newNode->next = NULL;\n     return newNode;\n}\n\nvoid insertEnd(Node **head, int data)\n{\n     Node *newNode = createNode(data);\n     if (*head == NULL)\n     {\n          *head = newNode;\n     }\n     else\n     {\n          Node *temp = *head;\n          while (temp->next != NULL)\n          {\n               temp = temp->next;\n          }\n          temp->next = newNode;\n     }\n}\n\nvoid displayList(Node *head)\n{\n     Node *temp = head;\n     while (temp != NULL)\n     {\n          printf(\"%d -> \", temp->data);\n          temp = temp->next;\n     }\n     printf(\"NULL\\n\");\n}\n\nvoid concatenateLists(Node **head1, Node *head2)\n{\n     if (*head1 == NULL)\n     {\n          *head1 = head2;\n     }\n     else\n     {\n          Node *temp = *head1;\n          while (temp->next != NULL)\n          {\n               temp = temp->next;\n          }\n          temp->next = head2;\n     }\n}\n\nint main()\n{\n     Node *list1 = NULL, *list2 = NULL;\n     int n, i, data;\n\n     clrscr(); // Clear the screen (Turbo C specific)\n\n     // Create first list\n     printf(\"Enter number of elements for the first list: \");\n     scanf(\"%d\", &n);\n     printf(\"Enter %d elements:\\n\", n);\n     for (i = 0; i < n; i++)\n     {\n          scanf(\"%d\", &data);\n          insertEnd(&list1, data);\n     }\n\n     // Create second list\n     printf(\"Enter number of elements for the second list: \");\n     scanf(\"%d\", &n);\n     printf(\"Enter %d elements:\\n\", n);\n     for (i = 0; i < n; i++)\n     {\n          scanf(\"%d\", &data);\n          insertEnd(&list2, data);\n     }\n\n     printf(\"First list: \");\n     displayList(list1);\n\n     printf(\"Second list: \");\n     displayList(list2);\n\n     concatenateLists(&list1, list2);\n\n     printf(\"Concatenated list: \");\n     displayList(list1);\n\n     getch(); // Wait for user input before closing (Turbo C specific)\n     return 0;\n}
`,
        },
      ],
    },
    {
      slipId: 27,
      questions: [
        {
          questionId: 1,
          text: `Implement Static implementation of circular queue of integers with following operation:<br> - Initialize()<br> - Insert()<br> - Delete()<br> - IsEmpty()<br> - IsFull()<br> - Display()`,
          marks: 20,
          sol: `#include<stdio.h>\n#define MAX 5 // Define the size of the queue\n\ntypedef struct\n{\n     int front, rear, size;\n     int queue[MAX];\n} CircularQueue;\n\n// Function to initialize the queue\nvoid Initialize(CircularQueue *cq)\n{\n     cq->front = cq->rear = -1;\n     cq->size = 0;\n}\n\n// Function to check if the queue is empty\nint isempty(CircularQueue *cq)\n{\n     return cq->size == 0;\n}\n\n// Function to check if the queue is full\nint isfull(CircularQueue *cq)\n{\n     return cq->size == MAX;\n}\n\n// Function to insert an element into the queue\nvoid insert(CircularQueue *cq, int value)\n{\n     if (isfull(cq))\n     {\n          printf(\"Queue is full!\\n\");\n          return;\n     }\n     if (isempty(cq))\n     {\n          cq->front = 0;\n     }\n     cq->rear = (cq->rear + 1) % MAX;\n     cq->queue[cq->rear] = value;\n     cq->size++;\n}\n\n// Function to delete an element from the queue\nvoid delete(CircularQueue *cq)\n{\n     if (isempty(cq))\n     {\n          printf(\"Queue is empty!\\n\");\n          return;\n     }\n     printf(\"Deleted element: %d\\n\", cq->queue[cq->front]);\n     cq->front = (cq->front + 1) % MAX;\n     cq->size--;\n}\n\n// Function to display the elements of the queue\nvoid display(CircularQueue *cq)\n{\n     if (isempty(cq))\n     {\n          printf(\"Queue is empty!\\n\");\n          return;\n     }\n     printf(\"Queue elements: \");\n     int i;\n     for (i = 0; i < cq->size; i++)\n     {\n          printf(\"%d \", cq->queue[(cq->front + i) % MAX]);\n     }\n     printf(\"\\n\");\n}\n\nint main()\n{\n     CircularQueue cq;\n     int choice, value;\n\n     clrscr(); // Clear the screen (Turbo C specific)\n     Initialize(&cq);\n\n     while (1)\n     {\n          printf(\"\\nCircular Queue Operations:\\n\");\n          printf(\"1. Insert\\n\");\n          printf(\"2. Delete\\n\");\n          printf(\"3. Display\\n\");\n          printf(\"4. Exit\\n\");\n          printf(\"Enter your choice: \");\n          scanf(\"%d\", &choice);\n\n          switch (choice)\n          {\n          case 1:\n               printf(\"Enter value to insert: \");\n               scanf(\"%d\", &value);\n               insert(&cq, value);\n               break;\n          case 2:\n               delete(&cq);\n               break;\n          case 3:\n               display(&cq);\n               break;\n          case 4:\n               return 0;\n          default:\n               printf(\"Invalid choice!\\n\");\n          }\n     }\n     getch(); // Wait for user input before closing (Turbo C specific)\n     return 0;\n}
`,
        },
        {
          questionId: 2,
          text: `Write a ‘C’ program to create Doubly Link list and display it.`,
          marks: 10,
          sol: `#include<stdio.h>\n#include<stdlib.h>\n\ntypedef struct Node\n{\n     int data;\n     struct Node *next;\n     struct Node *prev;\n} Node;\n\n// Function to create a new node\nNode *createNode(int data)\n{\n     Node *newNode = (Node *)malloc(sizeof(Node));\n     newNode->data = data;\n     newNode->next = NULL;\n     newNode->prev = NULL;\n     return newNode;\n}\n\n// Function to insert a node at the end of the doubly linked list\nvoid insertEnd(Node **head, int data)\n{\n     Node *newNode = createNode(data);\n     if (*head == NULL)\n     {\n          *head = newNode;\n     }\n     else\n     {\n          Node *temp = *head;\n          while (temp->next != NULL)\n          {\n               temp = temp->next;\n          }\n          temp->next = newNode;\n          newNode->prev = temp;\n     }\n}\n\n// Function to display the doubly linked list\nvoid displayList(Node *head)\n{\n     Node *temp = head;\n     printf(\"Doubly Linked List: \");\n     while (temp != NULL)\n     {\n          printf(\"%d \", temp->data);\n          temp = temp->next;\n     }\n     printf(\"\\n\");\n}\n\nint main()\n{\n     Node *head = NULL;\n     int n, i, data;\n\n     clrscr(); // Clear the screen (Turbo C specific)\n\n     printf(\"Enter number of elements: \");\n     scanf(\"%d\", &n);\n     printf(\"Enter %d elements:\\n\", n);\n     for (i = 0; i < n; i++)\n     {\n          scanf(\"%d\", &data);\n          insertEnd(&head, data);\n     }\n\n     displayList(head);\n\n     // Free allocated memory (optional for demonstration)\n     Node *temp;\n     while (head != NULL)\n     {\n          temp = head;\n          head = head->next;\n          free(temp);\n     }\n\n     getch(); // Wait for user input before closing (Turbo C specific)\n     return 0;\n}
`,
        },
      ],
    },
    {
      slipId: 28,
      questions: [
        {
          questionId: 1,
          text: `Write a ‘C’ program to create a Binary Search tree and implement following functions:<br> - Create Binary Search Tree<br> - Search a node in binary search tree<br> - Display a binary search tree (Post order Traversal)`,
          marks: 20,
          sol: `#include<stdio.h>\n#include<stdlib.h>\n\nstruct Tree\n{\n     int data;\n     struct Tree *left, *right;\n};\n\n// Function to create a new tree node\nstruct Tree *newNode(int data)\n{\n     struct Tree *newNode = (struct Tree *)malloc(sizeof(struct Tree));\n     newNode->data = data;\n     newNode->left = newNode->right = NULL;\n     return newNode;\n}\n\n// Function to insert a new node into the BST\nstruct Tree *create(struct Tree *root, int data)\n{\n     if (root == NULL)\n     {\n          return newNode(data);\n     }\n     if (data < root->data)\n     {\n          root->left = create(root->left, data);\n     }\n     else if (data > root->data)\n     {\n          root->right = create(root->right, data);\n     }\n     return root;\n}\n\n// Function to search for a value in the BST\nint search(struct Tree *root, int key)\n{\n     if (root == NULL)\n     {\n          return 0;\n     }\n     if (root->data == key)\n     {\n          return 1;\n     }\n     else if (key < root->data)\n     {\n          return search(root->left, key);\n     }\n     else\n     {\n          return search(root->right, key);\n     }\n}\n\n// Function to display the tree nodes in post-order\nvoid display(struct Tree *root)\n{\n     if (root != NULL)\n     {\n          display(root->left);\n          display(root->right);\n          printf(\"%d\\t\", root->data);\n     }\n}\n\nint main()\n{\n     struct Tree *root = NULL;\n     int data;\n\n     printf(\"Enter the data (-1 to stop):\\n\");\n     while (1)\n     {\n          scanf(\"%d\", &data);\n          if (data == -1)\n               break;\n          root = create(root, data);\n     }\n\n     printf(\"Binary Search Tree (Post-order Traversal):\\n\");\n     display(root);\n\n     printf(\"\\nEnter the element you want to search: \");\n     scanf(\"%d\", &data);\n     if (search(root, data))\n     {\n          printf(\"%d is found\\n\", data);\n     }\n     else\n     {\n          printf(\"%d is not found\\n\", data);\n     }\n\n     return 0;\n}
`,
        },
        {
          questionId: 2,
          text: `Write a ‘C’ program to read n integers and create two lists such that all positive numbers are in one list and negative numbers are in another list. Display both the lists.`,
          marks: 10,
          sol: `#include<stdio.h>\n#include<stdlib.h>\n\nstruct Node\n{\n     int data;\n     struct Node *next;\n};\n\nstruct Node *temp, *head1 = NULL, *head2 = NULL, *newNode, *ptr;\n\nstruct Node *create(struct Node *head, int data)\n{\n     newNode = (struct Node *)malloc(sizeof(struct Node));\n     newNode->data = data;\n     newNode->next = NULL;\n\n     if (head == NULL)\n          head = temp = newNode;\n     else\n     {\n          temp->next = newNode;\n          temp = newNode;\n     }\n\n     return head;\n}\n\nvoid display(struct Node *head)\n{\n     ptr = head;\n     while (ptr != NULL)\n     {\n          printf(\"%d\\t\", ptr->data);\n          ptr = ptr->next;\n     }\n}\n\nint main()\n{\n     int num, choice;\n\n     do\n     {\n          printf(\"Enter the number :\");\n          scanf(\"%d\", &num);\n          if (num >= 0)\n               head1 = create(head1, num);\n          else\n               head2 = create(head2, num);\n\n          printf(\"Do you want to add more Node(yes-1 & no-0) :\");\n          scanf(\"%d\", &choice);\n     } while (choice == 1);\n\n     printf(\"Positive Linked List :\\n\");\n     display(head1);\n     printf(\"\\nNegative Linked List :\\n\");\n     display(head2);\n}\n
`,
        },
      ],
    },
    {
      slipId: 29,
      questions: [
        {
          questionId: 1,
          text: `Write a ‘C’ program to create a Binary tree, traverse it using recursive operations like inorder, preorder and postorder and display the result of each one separately.`,
          marks: 20,
          sol: `#include<stdio.h>\n#include<stdlib.h>\n#include<conio.h>\n\n// Define the structure for a node in the binary tree\nstruct Node\n{\n     int data;\n     struct Node *left;\n     struct Node *right;\n};\n\n// Function to create a new node\nstruct Node *createNode(int data)\n{\n     struct Node *newNode = (struct Node *)malloc(sizeof(struct Node));\n     newNode->data = data;\n     newNode->left = NULL;\n     newNode->right = NULL;\n     return newNode;\n}\n\n// Function to perform inorder traversal\nvoid inorderTraversal(struct Node *root)\n{\n     if (root != NULL)\n     {\n          inorderTraversal(root->left);  // Visit left subtree\n          printf(\"%d \", root->data);     // Print node data\n          inorderTraversal(root->right); // Visit right subtree\n     }\n}\n\n// Function to perform preorder traversal\nvoid preorderTraversal(struct Node *root)\n{\n     if (root != NULL)\n     {\n          printf(\"%d \", root->data);      // Print node data\n          preorderTraversal(root->left);  // Visit left subtree\n          preorderTraversal(root->right); // Visit right subtree\n     }\n}\n\n// Function to perform postorder traversal\nvoid postorderTraversal(struct Node *root)\n{\n     if (root != NULL)\n     {\n          postorderTraversal(root->left);  // Visit left subtree\n          postorderTraversal(root->right); // Visit right subtree\n          printf(\"%d \", root->data);       // Print node data\n     }\n}\n\n// Main function\nint main()\n{\n     clrscr(); // Clear the screen\n     // Creating nodes for the binary tree\n     struct Node *root = createNode(1);\n     root->left = createNode(2);\n     root->right = createNode(3);\n     root->left->left = createNode(4);\n     root->left->right = createNode(5);\n     root->right->left = createNode(6);\n     root->right->right = createNode(7);\n\n     // Displaying the tree traversals\n     printf(\"Inorder Traversal: \");\n     inorderTraversal(root);\n     printf(\"\\n\");\n\n     printf(\"Preorder Traversal: \");\n     preorderTraversal(root);\n     printf(\"\\n\");\n\n     printf(\"Postorder Traversal: \");\n     postorderTraversal(root);\n     printf(\"\\n\");\n\n     getch(); // Wait for a key press to close the console window\n\n     return 0;\n}
`,
        },
        {
          questionId: 2,
          text: `Write a ‘C’ program to create Circular Singly Link list and display it.`,
          marks: 10,
          sol: `#include<stdio.h>\n#include<stdlib.h>\n#include<conio.h>\n\n// Define the structure for a node in the circular singly linked list\nstruct Node\n{\n     int data;\n     struct Node *next;\n};\n\n// Function to create a new node\nstruct Node *createNode(int data)\n{\n     struct Node *newNode = (struct Node *)malloc(sizeof(struct Node));\n     newNode->data = data;\n     newNode->next = NULL;\n     return newNode;\n}\n\n// Function to insert a node at the end of the circular singly linked list\nvoid insertEnd(struct Node **head, int data)\n{\n     struct Node *newNode = createNode(data);\n     if (*head == NULL)\n     {\n          // If the list is empty, make the new node the head and point it to itself\n          *head = newNode;\n          newNode->next = *head;\n     }\n     else\n     {\n          struct Node *temp = *head;\n          // Traverse to the last node\n          while (temp->next != *head)\n          {\n               temp = temp->next;\n          }\n          // Insert the new node and update pointers\n          temp->next = newNode;\n          newNode->next = *head;\n     }\n}\n\n// Function to display the circular singly linked list\nvoid displayList(struct Node *head)\n{\n     if (head == NULL)\n     {\n          printf(\"List is empty.\\n\");\n          return;\n     }\n     struct Node *temp = head;\n     // Traverse the list and print data\n     do\n     {\n          printf(\"%d \", temp->data);\n          temp = temp->next;\n     } while (temp != head);\n     printf(\"\\n\");\n}\n\n// Main function\nint main()\n{\n     struct Node *head = NULL; // Initialize head to NULL\n\n     clrscr(); // Clear the screen\n\n     // Inserting nodes into the circular singly linked list\n     insertEnd(&head, 10);\n     insertEnd(&head, 20);\n     insertEnd(&head, 30);\n     insertEnd(&head, 40);\n\n     // Displaying the circular singly linked list\n     printf(\"Circular Singly Linked List: \");\n     displayList(head);\n\n     getch(); // Wait for a key press to close the console window\n     return 0;\n}
`,
        },
      ],
    },
    {
      slipId: 30,
      questions: [
        {
          questionId: 1,
          text: `Implement Dynamic implementation of circular queue of integers with following operation:<br> - Initialize()<br> - Insert()<br> - Delete()<br> - IsEmpty()<br> - IsFull()<br> - Display()`,
          marks: 20,
          sol: `#include<stdio.h>\n#include<stdlib.h>\n#include<conio.h> // Include this header for clrscr()\n\n#define MAX 5 // Define the maximum size of the queue\n\n// Define the structure for the circular queue\nstruct CircularQueue\n{\n     int front, rear, size, capacity;\n     int *array;\n};\n\n// Function to initialize the circular queue\nvoid initialize(struct CircularQueue *queue, int capacity)\n{\n     queue->capacity = capacity;\n     queue->front = 0;\n     queue->rear = -1;\n     queue->size = 0;\n     queue->array = (int *)malloc(capacity * sizeof(int));\n}\n\n// Function to check if the queue is empty\nint isEmpty(struct CircularQueue *queue)\n{\n     return (queue->size == 0);\n}\n\n// Function to check if the queue is full\nint isFull(struct CircularQueue *queue)\n{\n     return (queue->size == queue->capacity);\n}\n\n// Function to insert an element into the queue\nvoid insert(struct CircularQueue *queue, int item)\n{\n     if (isFull(queue))\n     {\n          printf(\"Queue is full. Cannot insert %d\\n\", item);\n          return;\n     }\n     queue->rear = (queue->rear + 1) % queue->capacity;\n     queue->array[queue->rear] = item;\n     queue->size++;\n     printf(\"%d inserted into the queue.\\n\", item);\n}\n\n// Function to delete an element from the queue\nvoid delete(struct CircularQueue *queue)\n{\n     if (isEmpty(queue))\n     {\n          printf(\"Queue is empty. Nothing to delete.\\n\");\n          return;\n     }\n     int item = queue->array[queue->front];\n     queue->front = (queue->front + 1) % queue->capacity;\n     queue->size--;\n     printf(\"%d deleted from the queue.\\n\", item);\n}\n\n// Function to display the elements of the queue\nvoid display(struct CircularQueue *queue)\n{\n     if (isEmpty(queue))\n     {\n          printf(\"Queue is empty.\\n\");\n          return;\n     }\n     printf(\"Queue elements: \");\n     for (int i = 0; i < queue->size; i++)\n     {\n          int index = (queue->front + i) % queue->capacity;\n          printf(\"%d \", queue->array[index]);\n     }\n     printf(\"\\n\");\n}\n\n// Main function\nint main()\n{\n     struct CircularQueue queue;\n\n     initialize(&queue, MAX); // Initialize the queue with a capacity of MAX\n\n     clrscr(); // Clear the screen\n\n     insert(&queue, 10);\n     insert(&queue, 20);\n     insert(&queue, 30);\n     insert(&queue, 40);\n     insert(&queue, 50);\n\n     clrscr(); // Clear the screen before displaying\n\n     display(&queue);\n\n     delete(&queue);\n     delete(&queue);\n\n     clrscr(); // Clear the screen before displaying again\n\n     display(&queue);\n\n     insert(&queue, 60);\n     insert(&queue, 70);\n\n     clrscr(); // Clear the screen before displaying the final state\n\n     display(&queue);\n\n     free(queue.array); // Free the allocated memory for the queue\n\n     getch(); // Wait for a key press to close the console window\n\n     return 0;\n}
`,
        },
        {
          questionId: 2,
          text: `Write a ‘C’ program to sort elements of a singly linked list in ascending order and display the sorted List.`,
          marks: 10,
          sol: `#include<stdio.h>\n#include<stdlib.h>\n#include<conio.h>\n\n// Define the structure for a node in the singly linked list\nstruct Node\n{\n     int data;\n     struct Node *next;\n};\n\n// Function to create a new node\nstruct Node *createNode(int data)\n{\n     struct Node *newNode = (struct Node *)malloc(sizeof(struct Node));\n     newNode->data = data;\n     newNode->next = NULL;\n     return newNode;\n}\n\n// Function to insert a node at the end of the singly linked list\nvoid insertEnd(struct Node **head, int data)\n{\n     struct Node *newNode = createNode(data);\n     if (*head == NULL)\n     {\n          *head = newNode;\n     }\n     else\n     {\n          struct Node *temp = *head;\n          while (temp->next != NULL)\n          {\n               temp = temp->next;\n          }\n          temp->next = newNode;\n     }\n}\n\n// Function to display the singly linked list\nvoid displayList(struct Node *head)\n{\n     if (head == NULL)\n     {\n          printf(\"List is empty.\\n\");\n          return;\n     }\n     struct Node *temp = head;\n     while (temp != NULL)\n     {\n          printf(\"%d \", temp->data);\n          temp = temp->next;\n     }\n     printf(\"\\n\");\n}\n\n// Function to sort the singly linked list using Bubble Sort\nvoid sortList(struct Node *head)\n{\n     if (head == NULL)\n          return;\n\n     int swapped;\n     struct Node *ptr1;\n     struct Node *lptr = NULL;\n\n     // Bubble sort algorithm\n     do\n     {\n          swapped = 0;\n          ptr1 = head;\n\n          while (ptr1->next != lptr)\n          {\n               if (ptr1->data > ptr1->next->data)\n               {\n                    // Swap data\n                    int temp = ptr1->data;\n                    ptr1->data = ptr1->next->data;\n                    ptr1->next->data = temp;\n                    swapped = 1;\n               }\n               ptr1 = ptr1->next;\n          }\n          lptr = ptr1;\n     } while (swapped);\n}\n\n// Main function\nvoid main()\n{\n     clrscr();\n\n     struct Node *head = NULL; // Initialize head to NULL\n\n     // Insert elements into the singly linked list\n     insertEnd(&head, 30);\n     insertEnd(&head, 10);\n     insertEnd(&head, 20);\n     insertEnd(&head, 50);\n     insertEnd(&head, 40);\n\n     printf(\"Original List: \");\n     displayList(head);\n\n     sortList(head); // Sort the list\n\n     printf(\"Sorted List: \");\n     displayList(head);\n\n     getch();\n}
`,
        },
      ],
    },
  ],
  language: 'c',
}
